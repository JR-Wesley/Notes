---
dateCreated: 2025-08-19
dateModified: 2025-08-19
---
# Vector

`std::vector` 是 C++ 标准模板库 (STL) 中最常用和最重要的容器之一。它的设计目标是提供一个动态数组，结合了 C 风格数组的高效随机访问特性和动态内存管理的便利性。

以下是 `std::vector` 的核心实现原理：

### 1. 核心数据结构：三个指针

`std::vector` 通常由三个指针（或等效的迭代器）来管理其内部存储：

- **`start` / `begin`**: 指向当前已分配内存块中第一个元素的指针。
- **`finish` / `end`**: 指向当前已分配内存块中最后一个**已构造**元素的下一个位置的指针。`finish - start` 就是 `size()`。
- **`end_of_storage` / `capacity_end`**: 指向当前已分配内存块末尾的指针。`end_of_storage - start` 就是 `capacity()`。

这三个指针共同定义了 `vector` 的状态：

- **大小 (Size)**: `finish - start`
- **容量 (Capacity)**: `end_of_storage - start`

### 2. 动态增长策略

当向 `vector` 添加元素（如 `push_back`）导致 `size()` 即将超过 `capacity()` 时，需要进行扩容。

- **分配新内存**: 分配一块比当前容量更大的新内存块。标准**不规定**具体的增长因子，但实践中（如 GCC 的 libstdc++ 和 Clang 的 libc++）通常采用 **1.5 倍或 2 倍**的增长策略。选择 2 倍增长是为了摊销插入操作的平均时间复杂度为 O(1)。
- **移动/复制元素**: 将旧内存块中的所有现有元素**移动构造**（如果元素类型支持移动语义）或**复制构造**到新内存块中。
- **析构并释放旧内存**: 调用旧内存块中所有元素的析构函数，并释放旧的内存块。
- **更新指针**: 更新 `start`, `finish`, `end_of_storage` 指向新的内存块。

**关键点**:

- **移动语义**: C++11 引入移动语义后，如果元素类型有高效的移动构造函数（如 `std::string`, `std::vector` 本身），扩容时会优先使用移动，这比复制要快得多。
- **异常安全**: 扩容过程需要保证强异常安全。如果在移动/复制过程中抛出异常，`vector` 的状态（大小、元素）必须保持不变（通常通过先分配新内存，再复制/移动，成功后再释放旧内存来实现）。
- **迭代器失效**: 扩容会导致**所有**指向该 `vector` 的迭代器、指针和引用失效，因为底层内存地址改变了。

### 3. 内存管理

- **连续存储**: `std::vector` 保证其元素在内存中是**连续存储**的。这是它与 `std::list` 或 `std::deque` 的关键区别，也是它能提供高效随机访问（O(1)）和良好缓存局部性的基础。
- **`operator new`**: 通常使用 `operator new` 或 `std::allocator` 来分配原始内存块。`std::allocator` 是标准的内存分配器，负责分配和释放未初始化的内存。
- **对象构造/析构**:
    - **分配内存**和**构造对象**是分开的。`vector` 先分配一块原始内存（使用 `allocator::allocate`），然后在需要时（如 `push_back`, `resize`）在特定位置使用 `allocator::construct`（或 `placement new`）来构造对象。
    - 在对象被移除或 `vector` 销毁时，使用 `allocator::destroy`（或显式调用析构函数）来析构对象，然后才释放内存。

### 4. 关键操作的时间复杂度

- **随机访问 (`operator[]`, `at`, `front`, `back`)**: O(1)
- **在末尾插入 (`push_back`)**:
    - 平摊 O(1)（因为扩容是摊销成本）
    - 最坏情况 O(n)（当发生扩容时）
- **在末尾删除 (`pop_back`)**: O(1)
- **在任意位置插入/删除 (`insert`, `erase`)**: O(n)（因为需要移动插入点之后的所有元素）
- **获取大小 (`size`)**: O(1)
- **获取容量 (`capacity`)**: O(1)
- **调整大小 (`resize`)**:
    - 如果新大小 <= 容量: O(|new_size - old_size|)（构造或析构元素）
    - 如果新大小 > 容量: O(n)（需要扩容和移动所有元素）
- **预留空间 (`reserve`)**:
    - 如果 `n <= capacity()`: O(1)
    - 如果 `n > capacity()`: O(n)（需要扩容）

### 5. 与 `std::array` 和 `std::deque` 的对比

- **`std::array`**: 固定大小，栈上或静态存储，无动态分配，`size()` == `capacity()`。
- **`std::deque`**: 双端队列，非连续存储（通常由分段连续块组成），支持在两端高效插入/删除（O(1)），但随机访问略慢于 `vector`，迭代器可能在插入/删除时失效。

### 6. 示例简化实现 (概念性)

cpp

深色版本

```
template<typename T, typename Allocator = std::allocator<T>>
class vector {
private:
    T* start_;
    T* finish_;
    T* end_of_storage_;
    Allocator alloc_;

    // 分配新内存并复制/移动元素
    void grow_and_copy(size_t new_capacity) {
        T* new_start = alloc_.allocate(new_capacity);
        T* new_finish = new_start;

        try {
            // 将旧元素移动/复制到新内存
            for (T* it = start_; it != finish_; ++it, ++new_finish) {
                alloc_.construct(new_finish, std::move(*it)); // 优先移动
            }
        } catch (…) {
            // 异常处理：析构已构造的元素，释放内存，重新抛出
            while (new_finish != new_start) {
                alloc_.destroy(--new_finish);
            }
            alloc_.deallocate(new_start, new_capacity);
            throw;
        }

        // 析构并释放旧内存
        for (T* it = start_; it != finish_; ++it) {
            alloc_.destroy(it);
        }
        if (start_) {
            alloc_.deallocate(start_, end_of_storage_ - start_);
        }

        start_ = new_start;
        finish_ = new_finish;
        end_of_storage_ = new_start + new_capacity;
    }

public:
    void push_back(const T& value) {
        if (finish_ == end_of_storage_) {
            size_t new_capacity = capacity() ? capacity() * 2 : 1; // 简化的2倍增长
            grow_and_copy(new_capacity);
        }
        alloc_.construct(finish_, value);
        ++finish_;
    }

    size_t size() const { return finish_ - start_; }
    size_t capacity() const { return end_of_storage_ - start_; }
    bool empty() const { return start_ == finish_; }

    T& operator[](size_t index) { return *(start_ + index); }
    const T& operator[](size_t index) const { return *(start_ + index); }

    // … 其他成员函数 (析构函数, 构造函数, pop_back, begin, end 等)
};
```

**总结**: `std::vector` 的核心是**连续的动态数组**，通过**三个指针**管理大小和容量，利用**摊销策略**（如 2 倍增长）保证平摊高效的插入性能，并严格分离**内存分配**和**对象构造**。其连续存储特性使其成为需要高效随机访问和缓存友好的场景的首选容器。

# 哈希表

