# 堆栈

要理解 “堆栈对程序执行的作用” 以及 “函数调用内存需手动 free 的原因”，需要先明确**栈（Stack）和堆（Heap）的本质区别**—— 二者是程序运行时操作系统 / 编译器管理内存的两种核心区域，设计目标、管理方式、生命周期完全不同，这直接决定了它们的用法和注意事项。

## 一、先理清基础：栈（Stack） Vs 堆（Heap）

在 C/C++ 程序中，运行时内存空间主要分为 “栈” 和 “堆”（还有全局区、常量区等，但核心与函数执行相关的是前两者）。二者的核心差异如下表所示：

|对比维度|栈（Stack）|堆（Heap）|
|---|---|---|
|**管理主体**|编译器自动管理（无需开发者干预）|开发者手动管理（需 `malloc/free` 或 `new/delete`）|
|**内存分配方式**|先进后出（FILO），类似 “堆叠盘子”，有固定生长方向|动态分配，无固定顺序，内存块分散存储|
|**分配效率**|极高（仅需修改栈指针 `esp`/`rbp`，无系统调用）|较低（需遍历空闲内存块，可能触发内存碎片整理）|
|**内存大小**|固定且较小（通常几 MB，由操作系统预设）|灵活且大（理论上可占满系统空闲内存）|
|**生命周期**|与 “函数调用栈帧” 绑定，函数返回后自动释放|与函数生命周期无关，仅在手动释放或程序退出时释放|
|**使用场景**|函数局部变量、函数参数、函数返回地址|动态大小的数据（如变长数组、跨函数共享的数据）|

## 二、栈（Stack）：函数执行的 “临时工作台”

栈的核心作用是**支撑函数调用的执行流程**，编译器会为每个被调用的函数创建一个 “栈帧（Stack Frame）”，栈帧包含以下关键信息，且随函数调用 “压栈”、函数返回 “出栈”：

### 1. 栈帧的组成（以 `int add(int a, int b)` 为例）

当调用 `add(2,3)` 时，栈会按以下顺序压入数据（不同架构可能有差异，但逻辑一致）：

1. **函数返回地址**：记录 `add` 执行完后，回到调用者（如 `main`）的哪一行代码继续执行；
2. **函数参数**：`b=3`、`a=2`（参数压栈顺序通常从右到左）；
3. **函数局部变量**：如 `add` 内部定义的 `int temp = a + b`，`temp` 会存在栈帧中；
4. **栈基指针（ebp/rbp）**：固定指向当前栈帧的起始位置，用于快速定位参数和局部变量。

### 2. 栈的自动释放机制

当 `add` 执行完 `return temp` 后，编译器会自动执行以下操作：

- 从栈中取出 “返回地址”，跳回调用者；
- 将栈指针（esp/rsp）向上移动（回收当前栈帧的内存），此时 `a`、`b`、`temp` 的内存空间被 “标记为空闲”（无需开发者操作）。

**结论**：栈是函数执行的 “临时区”，所有在栈上分配的内存（局部变量、参数）都会随函数返回自动释放，开发者无需手动管理。

## 三、堆（Heap）：程序的 “长期存储仓库”

堆的核心作用是**存储 “生命周期不依赖函数调用” 的数据**—— 比如需要跨函数共享的数据、动态大小的数据（如用户输入长度的字符串）。

### 1. 堆内存的分配场景

当函数需要分配内存，且满足以下任一条件时，必须使用堆（不能用栈）：

- 内存需要**跨函数使用**：比如函数 A 分配一块内存，传给函数 B 使用，若用栈，函数 A 返回后栈内存已释放，函数 B 会访问 “野指针”；
- 内存大小**动态变化**：比如需要根据用户输入的 `n` 创建一个 `n` 元素的数组（栈不支持动态大小的数组，C99 的变长数组 VLA 本质仍在栈上，且受栈大小限制）；
- 内存需要**长期存在**：比如程序运行全程都需要的配置数据，栈无法满足（栈会随函数退出释放）。

### 2. 堆内存的手动管理（为什么需要 `free`）

堆的管理主体是**开发者**，操作系统仅提供 “分配内存”（如 `malloc`）和 “回收内存”（如 `free`）的系统调用，原因如下：

- 堆没有 “自动释放” 的触发条件：堆内存不与任何函数的生命周期绑定，编译器无法判断 “何时该释放”—— 比如函数 A 用 `malloc` 分配内存后，可能传给函数 B，函数 B 又传给函数 C，编译器不知道哪个函数是 “最后使用者”；
- 不手动 `free` 会导致内存泄漏：若分配的堆内存不手动释放，即使指针被销毁（如函数返回后指针变量出栈），堆上的内存块仍会被标记为 “已占用”，直到程序退出才会被操作系统回收。长期运行的程序（如服务器）若频繁泄漏，会逐渐耗尽系统内存，导致程序崩溃。

## 四、关键问题：“函数调用时分配的内存，即使要返回，指针需要 free”—— 这里的内存是 “堆内存”

你提到的 “函数调用时分配的内存需手动 `free`”，**特指在函数内通过 `malloc`/`calloc`/`realloc`（C）或 `new`（C++）分配的堆内存**，而非栈内存。举个例子理解：

### 反例（栈内存无需 `free`，且不能 `free`）

```c++
// 错误：栈内存不能用free
int* bad_func() {
    int x = 10;       // x在栈上（函数栈帧内）
    return &x;        // 函数返回后，x的栈内存已释放
}

int main() {
    int* p = bad_func(); 
    // p是“野指针”，访问*p会触发未定义行为（内存已被回收）
    // free(p); // 严重错误：free只能用于堆内存，free栈内存会崩溃
    return 0;
}
```

### 正确案例（堆内存需手动 `free`）

```c++
// 正确：堆内存需手动free
int* good_func(int size) {
    // 在堆上分配size个int的内存，返回指向堆内存的指针
    int* arr = (int*)malloc(size * sizeof(int)); 
    if (arr == NULL) { // 堆分配可能失败，必须检查
        exit(1);
    }
    // 给堆内存赋值（此时arr指向的堆内存不随函数返回释放）
    for (int i = 0; i < size; i++) {
        arr[i] = i;
    }
    return arr; // 返回堆内存的地址（指针本身在栈上，随函数返回出栈，但指向的堆内存还在）
}

int main() {
    int* p = good_func(5); 
    // 使用堆内存（p指向的堆内存有效）
    for (int i = 0; i < 5; i++) {
        printf("%d ", p[i]); // 输出 0 1 2 3 4
    }
    
    // 必须手动free堆内存，否则内存泄漏
    free(p); 
    p = NULL; // 避免“悬空指针”（free后p仍指向原地址，需置空）
    return 0;
}
```

**核心逻辑**：
函数内分配的堆内存，其生命周期由 `malloc` 和 `free` 控制，与函数是否返回无关。即使函数返回了堆内存的指针，堆内存本身仍 “占用” 着系统资源，必须在使用完后手动 `free`。

## 五、总结：栈和堆的核心区别与使用原则

|内存区域|核心作用|生命周期|管理方式|典型错误|
|---|---|---|---|---|
|栈|函数执行的临时工作台|随函数栈帧创建 / 销毁|编译器自动管理|返回栈指针（野指针）、free 栈内存|
|堆|长期存储 / 跨函数数据|随 `malloc`/`free` 控制|开发者手动管理|内存泄漏（不 free）、重复 free|

记住一句话：**栈是 “自动的临时区”，堆是 “手动的长期区”** —— 函数调用中涉及的内存是否需要 `free`，只看它在 “堆” 上还是 “栈” 上，与函数是否返回无关。


# new/delete malloc/free

`new`/`delete`（C++）和`malloc`/`free`（C/C++ 兼容）是内存管理的两组核心工具，虽然都能分配和释放堆内存，但在**语法、功能、安全性**上有本质区别，核心差异如下：

### 一、本质定位：语言层级不同

- **`malloc`/`free`**：是**C 语言标准库函数**（`<stdlib.h>`），C++ 为兼容 C 保留了它们，本质是 “系统调用的封装”（通过操作系统调用操作系统分配内存）。
- **`new`/`delete`**：是**C++ 关键字运算符**，由编译器直接支持，不仅能分配内存，还能自动调用构造 / 析构函数（面向对象特性的核心支持）。

### 二、核心差异对比表

|对比维度|`malloc`/`free`|`new`/`delete`|
|---|---|---|
|**语法形式**|函数调用，需指定内存大小（字节）：  <br>`int* p = (int*)malloc(4);`|运算符，直接指定类型，无需计算大小：  <br>`int* p = new int;`|
|**返回值类型**|返回`void*`，必须手动强转成目标类型（如`(int*)`）。|直接返回对应类型的指针，无需强转（类型安全）。|
|**内存分配失败**|返回`NULL`（需手动检查是否分配成功）。|默认抛出`bad_alloc`异常（需用`try/catch`捕获）；  <br>也可指定不抛异常：`int* p = new (nothrow) int;`（失败返回`nullptr`）。|
|**对象构造 / 析构**|仅分配 / 释放原始内存，不会调用**构造函数**和**析构函数**（无法初始化对象）。|`new`会自动调用构造函数初始化对象；  <br>`delete`会自动调用析函数清理资源（如释放成员指针的堆内存）。|
|**数组支持**|需手动计算数组总字节数（`n * sizeof(int)`），释放用`free`：  <br>`int* arr = (int*)malloc(5*sizeof(int));`|直接支持数组，语法更简洁（`[]`），释放需用`delete[]`：  <br>`int* arr = new int[5];`（分配 + 默认初始化）|
|**重载支持**|无法重载，功能固定。|可重载（通过`operator new`/`operator delete`），自定义内存分配逻辑（如内存池）。|

### 三、关键场景示例：暴露核心区别

#### 1. 对 “对象” 的处理（最核心差异）

C++ 中创建对象时，`new`会自动调用构造函数，`delete`会自动调用析构函数，而`malloc`/`free`做不到：

```cpp
class MyClass {
public:
    MyClass() { printf("构造函数调用\n"); }  // 构造函数
    ~MyClass() { printf("析构函数调用\n"); } // 析构函数
};

int main() {
    // 用malloc/free：仅分配内存，不调用构造/析构
    MyClass* p1 = (MyClass*)malloc(sizeof(MyClass)); // 无构造函数调用
    free(p1); // 无析构函数调用（若对象有堆内存成员，会泄漏）

    // 用new/delete：自动调用构造/析构
    MyClass* p2 = new MyClass; // 输出：构造函数调用
    delete p2; // 输出：析构函数调用（正确清理对象资源）
    return 0;
}
```


**结论**：管理对象时必须用`new`/`delete`，否则对象无法初始化 / 清理，必然导致逻辑错误或内存泄漏。

#### 2. 数组的处理

`new[]`/`delete[]`专门针对数组设计，而`malloc`需要手动计算大小，且释放时无区别：

```cpp
// 数组分配
int* arr1 = (int*)malloc(5 * sizeof(int)); // 需计算总字节数
int* arr2 = new int[5]; // 直接指定元素个数，更简洁

// 数组释放
free(arr1); // malloc分配的数组，用free释放
delete[] arr2; // new[]分配的数组，必须用delete[]（否则仅释放首元素，内存泄漏）
```

  

**注意**：`new int[5]`会为 5 个 int 分配内存并默认初始化（基本类型为 0），而`malloc`分配的内存是 “原始未初始化内存”（值随机）。

#### 3. 内存分配失败的处理

`malloc`返回`NULL`需手动检查，`new`默认抛异常：


```cpp
// malloc失败处理
int* p1 = (int*)malloc(1024 * 1024 * 1024); // 分配1GB内存，可能失败
if (p1 == NULL) {
    printf("malloc失败\n"); // 必须手动检查
}

// new失败处理（默认抛异常）
try {
    int* p2 = new int[1024 * 1024 * 1024];
} catch (const std::bad_alloc& e) {
    printf("new失败：%s\n", e.what()); // 需用try/catch捕获
}

// new不抛异常版本（类C风格）
int* p3 = new (std::nothrow) int[1024 * 1024 * 1024];
if (p3 == nullptr) {
    printf("new失败\n"); // 类似malloc的检查方式
}
```

### 四、混用的风险（严禁！）

`malloc`和`new`分配的内存**不能交叉释放**，否则会导致程序崩溃：


```cpp
int* p1 = (int*)malloc(4);
delete p1; // 错误：malloc分配的内存不能用delete释放（可能触发堆 corruption）

int* p2 = new int;
free(p2); // 错误：new分配的内存不能用free释放（同上）
```

  

**原因**：`new`/`delete`可能包含额外的内存管理信息（如对象大小、析构函数地址），`malloc`/`free`无法识别这些信息。

### 五、总结：如何选择？

1. **C++ 代码**：优先用`new`/`delete`（或智能指针`unique_ptr`/`shared_ptr`），尤其管理对象时 —— 利用其自动调用构造 / 析构的特性，避免资源泄漏。
2. **兼容 C 的代码**：若需与 C 库交互（如 C 库函数返回`malloc`分配的内存），则用`malloc`/`free`，确保分配 / 释放匹配。
3. **核心原则**：**一组分配 / 释放必须成对使用**，且`new[]`对应`delete[]`，`malloc`对应`free`，不可混用。


本质上，`new`/`delete`是 C++ 对`malloc`/`free`的 “面向对象增强”—— 不仅管内存，还管对象的生命周期。