> [!important] 封装继承多态
> C++ 面向对象的核心是通过**封装**实现数据安全，**继承**实现代码复用，**多态**实现接口灵活。

- **类与对象**：
    - 构造函数/析构函数、拷贝构造函数、赋值运算符。
    - `this` 指针、常量成员函数、友元函数。
    - 静态成员（`static`）、单例模式。
- **继承与多态**：
    - 公有/私有继承、虚函数、虚析构函数。
    - 抽象类、纯虚函数。

# 1. **类与对象（Class & Object）**

   - **C++ 核心特性**：封装数据和行为。
	- `public`：外部可直接访问（暴露的接口）。
	- `private`：仅类内部可访问（隐藏的实现细节）。
	- `protected`：类内部和子类可访问（用于继承场景）。

# 2. **构造函数与析构函数**

   - **C++ 特性**：
     - 构造函数：自动初始化对象。
     - 析构函数：自动释放资源。
   - **示例**：

     ```cpp
     class File {
     public:
         File(const char* path) { /* 打开文件 */ }
         ~File() { /* 关闭文件 */ }
     };
     ```

- **委派构造函数（C++11）**：允许一个构造函数调用同一类的其他构造函数，减少代码重复。

在 C++ 中，构造函数是类的特殊成员函数，用于在对象创建时初始化其成员变量。根据不同的需求和场景，C++ 提供了多种类型的构造函数，每种类型都有其独特的用途和调用时机。以下是 C++ 中所有构造函数的详细解析及其使用场景：

---

## **1. 默认构造函数（Default Constructor）**

### **定义**

- 无参数或所有参数都有默认值的构造函数。
- 如果用户未显式定义构造函数，编译器会自动生成一个默认构造函数。
- **一旦用户定义了其他构造函数，编译器将不再自动生成默认构造函数**。

### **特点**

- 自动初始化对象的成员变量（基本类型未初始化，类类型调用其默认构造函数）。
- 静态对象或全局对象的构造函数在程序启动时调用。

### **使用场景**

- 创建对象时无需传递参数。
- 初始化静态对象或全局对象。

### **示例**

cpp

深色版本

```
class MyClass {
public:
    MyClass() { // 默认构造函数
        std::cout << "Default Constructor" << std::endl;
    }
};

int main() {
    MyClass obj; // 调用默认构造函数
    return 0;
}
```

### **注意事项**

- 如果自定义了其他构造函数（如带参数的构造函数），必须显式定义默认构造函数，否则无法创建无参对象。
- 默认构造函数可能隐式调用（如数组初始化）。

---

## **2. 参数化构造函数（Parameterized Constructor）**

### **定义**

- 带参数的构造函数，允许在创建对象时传递初始值。

### **特点**

- 通过初始化列表或赋值语句初始化成员变量。
- 支持灵活的初始化逻辑（如验证参数合法性）。

### **使用场景**

- 需要为对象的成员变量提供初始值。
- 根据不同的参数组合初始化不同的对象状态。

### **示例**

cpp

深色版本

```
class Rectangle {
private:
    int width, height;
public:
    Rectangle(int w, int h) : width(w), height(h) { // 参数化构造函数
        std::cout << "Parameterized Constructor" << std::endl;
    }
};

int main() {
    Rectangle rect(10, 5); // 调用参数化构造函数
    return 0;
}
```

### **注意事项**

- 参数化构造函数可以重载（不同参数列表）。
- 使用初始化列表比赋值更高效，尤其是对复杂对象（如类成员）。

---

## **3. 拷贝构造函数（Copy Constructor）**

### **定义**

- 接受同类对象的常量引用作为参数的构造函数。
- 用于根据已有对象初始化新对象。

### **特点**

- 编译器会自动生成默认的拷贝构造函数（按成员逐个拷贝）。
- **默认拷贝构造函数可能导致浅拷贝问题**（如指针成员指向同一地址）。

### **使用场景**

- 对象作为值传递给函数（函数参数为对象）。
- 从函数返回对象（返回值为对象）。
- 用已有的对象初始化新对象。

### **示例**

cpp

深色版本

```
class Box {
private:
    int* data;
    int size;
public:
    Box(int s) : size(s) {
        data = new int[size];
    }
    // 自定义拷贝构造函数（深拷贝）
    Box(const Box& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }
    ~Box() { delete[] data; }
};

int main() {
    Box box1(10);
    Box box2 = box1; // 调用拷贝构造函数
    return 0;
}
```

### **注意事项**

- **浅拷贝问题**：默认拷贝构造函数会导致两个对象共享指针成员，析构时可能重复释放内存（导致崩溃）。
- 必须自定义拷贝构造函数处理动态资源（如指针、文件句柄）。

---

## **4. 移动构造函数（Move Constructor）**

### **定义**

- 接受同类对象的右值引用（`T&&`）作为参数的构造函数。
- 用于从临时对象“窃取”资源（如内存、文件句柄），避免不必要的拷贝。

### **特点**

- **C++11 引入**，显著提升大型对象的性能。
- 移动构造函数会将资源所有权从源对象转移到目标对象，并将源对象置为空。

### **使用场景**

- 返回临时对象（如函数返回值为对象）。
- 使用 `std::move` 显式转换左值为右值。
- 处理大型资源（如动态数组、字符串向量）。

### **示例**

cpp

深色版本

```
class Buffer {
private:
    std::vector<int> data;
public:
    Buffer(size_t size) : data(size) {
        std::cout << "Buffer created with size " << size << std::endl;
    }
    // 移动构造函数
    Buffer(Buffer&& other) noexcept {
        data = std::move(other.data); // 窃取资源
        std::cout << "Buffer moved" << std::endl;
    }
};

Buffer createBuffer() {
    return Buffer(100); // 返回临时对象，调用移动构造函数
}

int main() {
    Buffer b = createBuffer(); // 调用移动构造函数
    return 0;
}
```

### **注意事项**

- 移动构造函数必须标记为 `noexcept`（避免异常传播）。
- 移动后源对象应处于有效但未定义的状态（如 `nullptr`、空数组）。

---

## **5. 委托构造函数（C++11）**

### **定义**

- 一个构造函数调用另一个构造函数（通过初始化列表）。
- 避免代码重复，简化构造函数逻辑。

### **特点**

- **只能在初始化列表中调用**，不能在函数体内。
- 支持构造函数链式调用（如从无参构造函数调用带参数的构造函数）。

### **使用场景**

- 多个构造函数共享相同的初始化逻辑。
- 避免重复代码（如默认值的设置）。

### **示例**

cpp

深色版本

```
class Person {
private:
    std::string name;
    int age;
public:
    // 委托构造函数
    Person() : Person("Unknown", 0) {}
    Person(std::string n) : Person(n, 0) {}
    Person(std::string n, int a) : name(n), age(a) {
        std::cout << "Person constructed" << std::endl;
    }
};

int main() {
    Person p1;           // 调用无参构造函数
    Person p2("Alice");  // 调用单参构造函数
    return 0;
}
```

### **注意事项**

- 委托构造函数不能形成循环调用（如 A 调用 B，B 调用 A）。
- 初始化列表中的委托必须是第一个操作。

---

## **6. 显式构造函数（Explicit Constructor）**

### **定义**

- 使用 `explicit` 关键字修饰的构造函数。
- **禁止隐式类型转换**（如将基本类型隐式转换为类对象）。

### **特点**

- 仅允许显式调用构造函数。
- 防止意外的隐式转换导致的歧义或错误。

### **使用场景**

- 构造函数只有一个参数（或除第一个参数外其他参数都有默认值）。
- 避免隐式转换引发的潜在错误。

### **示例**

cpp

深色版本

```
class String {
private:
    std::string value;
public:
    explicit String(const char* s) : value(s) {} // 禁止隐式转换
};

void print(const String& s) {
    std::cout << s.value << std::endl;
}

int main() {
    String s = "Hello"; // 错误！需要显式转换
    String s2("Hello"); // 正确
    print("Hello");     // 错误！隐式转换被禁止
    print(String("Hello")); // 正确
    return 0;
}
```

### **注意事项**

- `explicit` 只能用于单参数构造函数（或除第一个参数外其他参数有默认值的构造函数）。
- `explicit` 不适用于拷贝构造函数或移动构造函数。

---

## **7. 静态对象的构造函数**

### **定义**

- 静态对象包括程序级别的全局静态对象和类级别的静态成员对象。
- 其构造函数在程序启动时调用，析构函数在程序结束时调用。

### **特点**

- 静态对象的生命周期与程序相同。
- 静态对象的构造函数仅调用一次。

### **使用场景**

- 单例模式（确保全局唯一实例）。
- 初始化全局资源（如日志系统、配置管理器）。

### **示例**

cpp

深色版本

```
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance; // 静态局部变量，首次访问时构造
        return instance;
    }
private:
    Singleton() { std::cout << "Singleton constructed" << std::endl; }
    ~Singleton() { std::cout << "Singleton destructed" << std::endl; }
};

int main() {
    Singleton& s = Singleton::getInstance(); // 首次调用构造函数
    return 0; // 程序结束时调用析构函数
}
```

### **注意事项**

- 静态局部变量的构造函数在首次访问时调用，避免静态初始化顺序问题。
- 静态对象的析构顺序与构造顺序相反。

---

## **总结对比表**

|构造函数类型|定义方式|调用场景|注意事项|
|---|---|---|---|
|默认构造函数|无参数或所有参数有默认值|无参对象创建、静态/全局对象初始化|自定义后需显式定义|
|参数化构造函数|带参数|需要初始化成员变量的场景|支持重载，推荐使用初始化列表|
|拷贝构造函数|`const 类名&`|对象复制、值传递、返回对象|需处理深拷贝，避免浅拷贝问题|
|移动构造函数|`类名&&`|返回临时对象、`std::move`、大型资源管理|需标记 `noexcept`，移动后源对象置为空|
|委托构造函数|调用其他构造函数（初始化列表）|多构造函数共享初始化逻辑|不能循环调用，只能在初始化列表中使用|
|显式构造函数|`explicit`|防止隐式类型转换（如基本类型转类对象）|仅适用于单参数构造函数|
|静态对象的构造函数|静态局部变量或静态成员|全局资源初始化、单例模式|避免静态初始化顺序问题|

---

## **关键点总结**

1. **默认构造函数**：未定义时由编译器生成，但自定义后需显式声明。
2. **参数化构造函数**：支持灵活初始化，推荐使用初始化列表。
3. **拷贝构造函数**：默认实现可能导致浅拷贝问题，需自定义深拷贝。
4. **移动构造函数**：优化资源管理，避免不必要的拷贝。
5. **委托构造函数**：减少代码重复，简化构造逻辑。
6. **显式构造函数**：防止隐式转换，确保类型安全。
7. **静态对象的构造函数**：生命周期与程序一致，需注意初始化顺序问题。

通过合理使用这些构造函数，可以更高效地管理对象的生命周期、资源分配和初始化逻辑，提升代码的健壮性和性能。

# 3. 继承

C++ 通过 `class 子类 : 继承方式 父类` 语法实现继承，继承方式（`public`/`private`/`protected`）控制父类成员在子类中的访问权限（默认 `private`）。

```cpp
// 父类：通用动物
class Animal {
protected:  // 受保护成员：子类可访问
	string name;
public:
	Animal(string n) : name(n) {}
	void eat() {  // 通用行为
		cout << name << " is eating." << endl;
	}
	virtual void makeSound() {  // 虚函数：允许子类重写
		cout << name << " makes a sound." << endl;
	}
};

// 子类：狗（继承自动物）
class Dog : public Animal {
public:
	// 继承父类构造函数
	Dog(string n) : Animal(n) {}
	
	// 重写父类方法（实现狗的特有行为）
	void makeSound() override {
		cout << name << " barks: Woof!" << endl;
	}
	
	// 新增子类特有方法
	void fetch() {
		cout << name << " is fetching the ball." << endl;
	}
};
```

# 4. 多态（Polymorphism）：接口复用与动态行为

多态是指**同一接口（如父类指针 / 引用）可以表现出不同的行为，具体行为由实际对象类型决定**，分为 “编译期多态”（函数重载）和 “运行期多态”（虚函数）。而**虚函数（Virtual function）** 和**抽象类（Abstract Class）** 是实现多态的关键技术手段，三者紧密关联：虚函数是多态的基础机制，抽象类则是多态的一种高级应用形式（定义接口规范）。

- **接口统一**：用统一的父类接口操作不同子类对象，无需关心具体类型。
- **动态绑定**：运行时根据对象实际类型执行对应方法，提高代码灵活性。

## 一、多态：同一接口，不同实现

多态的核心思想是：**用统一的父类接口（如指针或引用）操作不同的子类对象时，程序会根据对象的实际类型执行对应的方法**，而不是接口的静态类型。

例如，“动物” 是一个父类，“狗” 和 “猫” 是子类：

```cpp
// 父类
class Animal {
public:
    // 虚函数：关键！为多态提供支持
    virtual void makeSound() { 
        cout << "动物发出声音" << endl; 
    }
};

// 子类1
class Dog : public Animal {
public:
    // 重写父类的虚函数
    void makeSound() override { 
        cout << "狗汪汪叫" << endl; 
    }
};

// 子类2
class Cat : public Animal {
public:
    // 重写父类的虚函数
    void makeSound() override { 
        cout << "猫喵喵叫" << endl; 
    }
};
```

多态的体现：用父类指针指向不同引用指向子类对象，调用方法时会执行子类的实现：

```cpp
int main() {
    Animal* animal1 = new Dog();  // 父类指针指向Dog对象
    Animal* animal2 = new Cat();  // 父类指针指向Cat对象
    
    animal1->makeSound();  // 输出：狗汪汪叫（实际执行Dog的方法）
    animal2->makeSound();  // 输出：猫喵喵叫（实际执行Cat的方法）
    
    delete animal1;
    delete animal2;
    return 0;
}
```

**本质**：多态通过 “动态绑定” 实现 —— 程序在运行时才确定要调用的具体方法（而非编译期根据指针类型确定）。

## 二、虚函数：多态的 “开关”

虚函数是**被 `virtual` 关键字修饰的成员函数**，它是 C++ 实现多态的基础。其核心作用是：**允许子类重写（override）父类的方法，并在运行时根据对象实际类型调用对应的重写版本**。

1. **父类声明**：在父类中用 `virtual` 声明函数（如 `virtual void makeSound()`）。
2. **子类重写**：子类用 `override` 关键字显式重写（C++11 起推荐，确保重写正确），函数签名（返回类型、参数列表）必须与父类完全一致。
3. **动态绑定**：只有通过**父类指针或引用**调用虚函数时，才会触发多态（动态绑定）；直接用子类对象调用时，行为与普通函数相同。

如果没有 `virtual`，函数调用会在编译期根据指针类型（而非对象类型）确定，无法实现多态：

```cpp
class Animal {
public:
    void makeSound() {  // 非虚函数
        cout << "动物发出声音" << endl; 
    }
};

// …（Dog和Cat类定义同上）

int main() {
    Animal* animal = new Dog();
    animal->makeSound();  // 输出：动物发出声音（编译期绑定，调用父类方法）
    return 0;
}
```

## 三、抽象类：多态的 “接口规范”

抽象类是**包含纯虚函数（Pure Virtual Function）的类**，它不能实例化对象，只能作为父类被继承。其核心作用是：**定义 “必须实现的接口”，强制子类提供具体实现，从而规范多态行为**。

- 纯虚函数的定义：表示该函数没有默认实现，必须由子类重写：

```cpp
class Animal {  // 抽象类（因为包含纯虚函数）
public:
    // 纯虚函数：只有声明，没有实现
    virtual void makeSound() = 0; 
};
```

- 抽象类的特性
	1. **不能实例化**：`Animal animal;` 或 `new Animal();` 都会编译错误（抽象类是 “接口”，不是 “具体对象”）。
	2. **强制重写**：子类必须重写所有纯虚函数，否则子类也会成为抽象类（无法实例化）。
	3. **定义接口**：抽象类本质是 “接口规范”，例如 `Animal` 规定 “所有动物必须能发出声音”，但不关心具体怎么叫（由子类实现）。

```cpp
class Dog : public Animal {
public:
    void makeSound() override {  // 必须重写，否则Dog也是抽象类
        cout << "狗汪汪叫" << endl;
    }
};
```

# 运算符重载（Operator Overloading）

   - **C++ 特性**：自定义类的运算符行为。
   - **示例**：

 ```cpp
 class Vector {
 public:
	 Vector operator+(const Vector& other) {
		 return Vector(x + other.x, y + other.y);
	 }
 };
```
