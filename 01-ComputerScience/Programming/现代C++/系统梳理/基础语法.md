
> 基础语法注重与 C 不同的特性。包括基础的数据类型、对函数的增强、一些其他特性。

# 数据类型

## 强类型

C++ 的 “强类型” 特性体现在对类型的严格区分和对隐式转换的限制上，C 语言允许宽松的隐式转换（弱类型特征）。这种设计的核心目标是**在编译期发现类型不匹配的错误**，减少运行时异常，提升代码安全性。其核心思路是：**除非开发者明确指示（显式转换），否则编译器默认禁止可能不安全的类型混用**。

> [!important] 强类型语言的核心特征
> **不同类型之间的操作受到严格限制，类型转换（尤其是隐式转换）需要满足明确的规则，不允许随意的、可能导致歧义的类型混用**。

C++ 的强类型体现在：

- 每种类型有明确的语义和操作限制（如 `int` 和 `float` 不能随意混用）；
- 隐式转换仅在 “安全且无歧义” 的场景下允许（如 `int`→`long`）；
- 多数跨类型操作需要显式转换（如 `void*` → `int*`）。

### 1. `void*` 的转换

- **C 语言**：`void*` 可以隐式转换为任何指针类型，无需显式转换
- **C++ 语言**：`void*` 不能隐式转换为其他指针类型，必须显式转换：

```cpp
void* ptr = new int[10];
// int* int_ptr = ptr;  // C++编译错误：必须允许void*隐式转换
int* int_ptr = static_cast<int*>(ptr);  // 必须显式转换
```

### 2. 整数与指针的转换

- **C 语言**：整数和指针可以随意隐式转换（风险极高）：
- **C++ 语言**：禁止整数与指针的隐式转换，必须显式转换（且不推荐）：

```cpp
int x = 0x7fffffff;
// int* ptr = x;  // C++编译错误：整数不能隐式转为指针
int* ptr = reinterpret_cast<int*>(x);  // 必须显式转换（不推荐）
```

### 3. 枚举类型的转换

- **C 语言**：枚举常量本质是 `int`，可与整数随意隐式转换：
- **C++ 语言**：枚举是独立类型，与整数的转换需显式进行：

```cpp
enum Color { RED, GREEN };
// Color c = 1;  // C++编译错误：整数不能隐式转为枚举
Color c = static_cast<Color>(1);  // 必须显式转换

// int x = RED;  // C++11前允许（兼容C），但现代C++建议显式转换
int x = static_cast<int>(RED);
```

更严格的是 C++11 引入的 `enum class`（强类型枚举），完全禁止与整数隐式转换：

```cpp
enum class Color { RED, GREEN };
// int x = Color::RED;  // 编译错误：强类型枚举不能隐式转为整数
```

### 4. 布尔类型的转换

- **C 语言**：任何整数 / 指针都可隐式视为 “布尔值”（0 为假，非 0 为真）：
- **C++ 语言**：虽然也允许整数 / 指针隐式转为 `bool`（兼容 C 的常见场景），但限制更严格：
	- 仅允许 “零值→`false`，非零值→`true`” 的转换；
	- 反之，`bool` 转为整数时，`true` 固定为 1（C 中可能因实现不同而变化）：

	```cpp
	bool b = true;
	int x = b;  // C++中x必为1（C中可能是其他非零值）
	```

### 5. 窄化转换（Narrowing Conversion）

- **C 语言**：允许隐式窄化转换（如 `double`→`int` 可能丢失小数部分）：
- **C++ 语言**：禁止隐式窄化转换（编译错误）：

```cpp
double d = 3.14;
// int x = d;  // C++编译错误：不允许double隐式转为int（窄化）
int x = static_cast<int>(d);  // 必须显式转换（明确告知编译器接受截断）
```

注意：列表初始化（`{}`）对窄化转换的检查更严格，完全禁止任何可能丢失信息的转换。

## 类型转换

在 C++ 中，四种强制类型转换（`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`）各有其特定的用途和限制。以下是它们的详细解析：

---

### **1. `static_cast`**

-  **作用**
	- **编译时类型检查**：在编译阶段进行类型合法性验证。
	- **基本类型转换**：如 `int` 转 `double`、`float` 转 `int`。
	- **类层次结构中的转换**：支持上行转换（派生类 → 基类，安全）和下行转换（基类 → 派生类，需谨慎）。
	- **`void*` 指针转换**：将 `void*` 转换为具体类型的指针。
- **使用场景**

1. **基本类型转换**：

- ```
    double d = 3.14;
    int i = static_cast<int>(d); // 输出 3
    ```

- **上行转换（安全）**：

- ```
    class Base {};
    class Derived : public Base {};
    Derived d;
    Base* b = static_cast<Base*>(&d); // 合法，派生类指针转基类指针
    ```

- **下行转换（需谨慎）**：

1. ```
    Base* b = new Derived();
    Derived* d = static_cast<Derived*>(b); // 合法，但无运行时检查



- **下行转换风险**：若基类指针实际指向非目标类型对象，可能导致未定义行为。
- **不支持跨继承链转换**：如无继承关系的类之间转换会报错。

---

### **2. `dynamic_cast`**

- **作用**
	- **运行时类型检查**：依赖 RTTI（Run-Time Type Information），仅适用于多态类型（包含虚函数的类）。
	- **安全向下转换**：检查转换是否合法，失败时返回 `nullptr`（指针）或抛出异常（引用）。
- **使用场景**

1. **多态类型的安全向下转换**：

2. ```
    class Base {
    public:
        virtual ~Base() {} // 必须有虚函数
    };
    class Derived : public Base {};
    
    Base* b = new Derived();
    Derived* d = dynamic_cast<Derived*>(b); // 成功，d != nullptr
    if (d) {
        // 使用 d
    } else {
        // 转换失败
    }
    ```

- **仅限多态类型**：基类必须有虚函数，否则编译错误。
- **性能开销**：运行时类型检查会增加额外开销，不适合频繁调用。
- **交叉转换限制**：无法在无继承关系的类之间转换。

---

### **3. `const_cast`**

- **作用**
	- **添加或移除 `const`/`volatile` 属性**：修改对象的访问权限，而非实际类型。
	- **典型用途**：绕过 `const` 限制（需谨慎，可能导致未定义行为）。
-  **使用场景**

1. **修改 `const` 对象的指针**：

- ```
    const int a = 42;
    int* p = const_cast<int*>(&a);
    *p = 43; // 未定义行为（修改 const 对象）
    ```

- **调用非 `const` 成员函数**：

1. ```
    class MyClass {
    public:
        void non_const_func() { /* ... */ }
    };
    
    const MyClass obj;
    MyClass* p = const_cast<MyClass*>(&obj);
    p->non_const_func(); // 未定义行为（修改 const 对象）
    ```

- **风险性**：修改 `const` 对象可能导致未定义行为，需严格控制使用场景。
- **仅限指针/引用**：`const_cast` 只能用于指针或引用类型。

---

### **4. `reinterpret_cast`**

- **作用**
	- **底层指针/地址转换**：将指针类型转换为不相关类型，或指针与整数类型互转。
	- **无类型检查**：完全依赖程序员对内存布局的理解，高度危险。

- **使用场景**

1. **指针类型转换**：

- ```
    int a = 10;
    int* p = &a;
    char* c = reinterpret_cast<char*>(p); // 将 int* 转为 char*
    ```

- **指针与整数互转**：

1. ```
    int* p = new int(42);
    uintptr_t addr = reinterpret_cast<uintptr_t>(p); // 指针转整数
    int* p2 = reinterpret_cast<int*>(addr); // 整数转指针
    ```

- **危险性**：转换后若访问非法内存，可能导致崩溃或未定义行为。
- **平台依赖**：指针与整数的大小和对齐方式可能因平台不同而变化。
- **仅限专家使用**：需充分理解内存布局和目标平台特性。

---

### **对比总结**

|转换类型|用途|安全性|适用场景|示例|
|---|---|---|---|---|
|`static_cast`|编译时检查的类型转换|高|基本类型、类继承转换|`int → double`|
|`dynamic_cast`|运行时类型检查|中|多态类型的向下转换|`Base* → Derived*`|
|`const_cast`|添加/移除 `const`/`volatile` 属性|低|修改 `const` 对象的访问权限|`const int* → int*`|
|`reinterpret_cast`|低层指针/地址转换|极低|指针类型互转、指针与整数互转|`int* → char*`|

1. **优先使用 `static_cast`**：大多数类型转换需求可通过 `static_cast` 满足。
2. **多态类型使用 `dynamic_cast`**：需运行时类型检查时（如向下转换）。
3. **谨慎使用 `const_cast`**：仅在明确知道后果时修改 `const` 属性。
4. **避免 `reinterpret_cast`**：除非处理底层硬件或协议，否则尽量避免。

## 自动类型推导（C++11）

C++11 及后续标准引入了**自动类型推导**机制，核心工具包括 `auto`、`decltype` 以及 C++14 新增的 `decltype(auto)`。这些特性大幅简化了代码编写（尤其是模板和泛型编程中），同时保持了类型安全性。

### `auto`：根据初始化表达式推导变量类型

`auto` 的核心功能是**让编译器根据变量的初始化表达式自动推导其类型**，无需显式声明。其设计初衷是简化复杂类型（如模板迭代器、lambda 表达式类型）的声明。

- 基本用法与推导规则

`auto` 必须结合初始化表达式使用（变量必须初始化），编译器会根据表达式的类型推导变量类型，并忽略**顶层 const/volatile 和引用**。

```cpp
// 基础类型推导
auto a = 10;         // a的类型：int（推导自整数字面量10）
auto b = 3.14;       // b的类型：double（推导自浮点字面量3.14）
auto c = 'a';        // c的类型：char
auto d = true;       // d的类型：bool

// 忽略顶层const和引用
const int x = 5;
auto x1 = x;         // x1的类型：int（顶层const被忽略）
auto& x2 = x;        // x2的类型：const int&（加&后保留底层const）

int y = 10;
int& ry = y;
auto z = ry;         // z的类型：int（引用被忽略，推导为被引用类型）
auto& rz = ry;       // rz的类型：int&（加&后保留引用）
```

**关键规则**：

- `auto` 推导时会 “退化” 类型（类似数组名退化为指针、函数名退化为函数指针）：

    ```cpp
    int arr[5] = {1,2,3,4,5};
    auto arr1 = arr;    // arr1的类型：int*（数组名退化）
    auto& arr2 = arr;   // arr2的类型：int(&)[5]（加&后保留数组类型）
    ```

- 若初始化表达式是引用，`auto` 会推导为被引用的类型（而非引用本身），除非显式添加 `&`。
- C++11 中 `auto` 仅用于变量声明，C++14 扩展了其适用场景：
- **函数返回类型推导**：

    ```cpp
    // C++14起支持，编译器根据return语句推导返回类型
    auto add(int a, double b) {
        return a + b;  // 返回类型：double（int隐式转换为double）
    }
    ```

    注意：若函数有多个 return 语句，所有返回类型必须可推导为同一类型，否则编译错误。

- **lambda 表达式参数**：

    ```cpp
    // C++14起，lambda参数可使用auto（本质是泛型lambda）
    auto sum = [](auto a, auto b) { return a + b; };
    sum(1, 2);       // 推导为int+int，返回3
    sum(3.14, 2.7);  // 推导为double+double，返回5.84
    ```

- 3. `auto` 的限制
- 不能用于未初始化的变量：`auto x;`（编译错误，无初始化表达式无法推导）。
- 不能用于函数参数（非 lambda）：`void func(auto x) {}`（C++17 前不支持，C++20 起可用于模板函数简化）。
- 不能推导数组类型（除非用引用）：如上述 `arr1` 会退化为指针。

### `decltype`：推导表达式的精确类型

`decltype`（“declare type” 的缩写）用于**推导表达式的类型**，但不执行表达式（仅分析类型）。与 `auto` 不同，它会完整保留表达式的类型信息（包括 const、volatile、引用等），且无需初始化变量。

#### 1. 基本用法

语法：`decltype(表达式) 变量名;`（变量可初始化也可不初始化）。

```cpp
int x = 10;
const int& rx = x;

// 推导变量类型
decltype(x) a;       // a的类型：int（x是int）
decltype(rx) b = x;  // b的类型：const int&（rx是const int&，保留引用和const）

// 推导表达式类型
decltype(x + 3) c;   // c的类型：int（x+3是int类型的表达式）
decltype(x * 1.5) d; // d的类型：double（int*double结果为double）
```

#### 2. 特殊规则：表达式的值类别影响推导结果

`decltype` 的推导结果与表达式的 “值类别”（lvalue/xvalue/prvalue）密切相关：

- 若表达式是**左值**（可取地址的对象），`decltype(表达式)` 推导为 “左值引用类型”。
- 若表达式是**纯右值**（临时对象），`decltype(表达式)` 推导为表达式的类型本身。

最典型的例子是 “变量名加括号” 的情况：

```cpp
int y = 20;

// 情况1：表达式是变量名（左值，但decltype对变量名特殊处理）
decltype(y) e;       // e的类型：int（变量名直接推导为其类型）

// 情况2：表达式是带括号的变量名（视为左值表达式）
decltype((y)) f = y; // f的类型：int&（(y)是左值表达式，推导为引用）
```

其他例子：

```cpp
int arr[5];
decltype(arr) g;     // g的类型：int[5]（数组名是左值，但变量名直接推导为数组类型）
decltype((arr)) h;   // h的类型：int(&)[5]（(arr)是左值表达式，推导为数组引用）
```

#### 3. 适用场景

`decltype` 的核心价值在于**保留类型的精确信息**，适合以下场景：

- **声明与表达式类型一致的变量**（无需初始化）：

    ```cpp
    vector<int> v;
    decltype(v.begin()) it;  // it的类型：vector<int>::iterator（与v.begin()返回类型一致）
    ```

- **模板中推导复杂类型**：

    ```cpp
    template <typename T, typename U>
    void func(T t, U u) {
        decltype(t + u) result;  // 推导t+u的类型，无需知道T和U具体是什么
        result = t + u;
    }
    ```

- **定义函数返回类型**（配合尾置返回类型，C++11 起）：

    ```cpp
    // 尾置返回类型：用decltype推导返回类型（依赖参数类型）
    template <typename T, typename U>
    auto add(T t, U u) -> decltype(t + u) {
        return t + u;
    }
    ```

### 三、`decltype(auto)`：结合 `auto` 与 `decltype` 的优势

C++14 引入 `decltype(auto)`，它的行为是：**用 `auto` 的语法（根据初始化推导），但采用 `decltype` 的推导规则（保留精确类型）**。主要用于函数返回类型推导，解决 `auto` 在转发场景中丢失引用 /const 的问题。

#### 1. 基本用法

- **变量声明**：与 `decltype` 类似，但必须初始化（因为带 `auto`）。

    ```cpp
    int x = 10;
    int& rx = x;
    
    decltype(auto) a = x;    // a的类型：int（同decltype(x)）
    decltype(auto) b = rx;   // b的类型：int&（同decltype(rx)，保留引用）
    decltype(auto) c = (x);  // c的类型：int&（同decltype((x))，左值表达式推导为引用）
    ```

- **函数返回类型**：完美转发返回值的类型（保留引用、const 等）。
    例如，实现一个 “转发函数”，返回另一个函数的结果，且保留其类型：

    ```cpp
    int global = 100;
    
    int& get_ref() { return global; }  // 返回int&
    int get_val() { return global; }   // 返回int
    
    // 用decltype(auto)推导返回类型，保留原函数的返回类型
    decltype(auto) forward_ref() { return get_ref(); }  // 返回int&
    decltype(auto) forward_val() { return get_val(); }  // 返回int
    
    int main() {
        forward_ref() = 200;  // 合法：forward_ref返回int&，可赋值
        // forward_val() = 300;  // 错误：forward_val返回int（右值），不可赋值
        return 0;
    }
    ```

#### 2. 与 `auto` 的关键区别

`auto` 推导会忽略引用和顶层 const，而 `decltype(auto)` 会完整保留：

```cpp
int x = 5;
const int& rx = x;

auto a = rx;          // a的类型：int（忽略引用和const）
decltype(auto) b = rx;// b的类型：const int&（保留引用和const）
```

### 四、`auto`、`decltype`、`decltype(auto)` 的对比总结

|特性|`auto`|`decltype(表达式)`|`decltype(auto)`|
|---|---|---|---|
|核心功能|推导变量类型（忽略顶层 const / 引用）|推导表达式类型（保留所有类型信息）|用 `auto` 语法，按 `decltype` 规则推导|
|是否需要初始化|必须（变量初始化）|可选（可仅声明类型）|必须（带 `auto` 特性）|
|引用 /const 处理|忽略顶层，需显式 `&` 保留|完整保留（依赖表达式值类别）|完整保留（同 `decltype`）|
|典型场景|简化变量声明（如迭代器、lambda）|模板类型推导、函数返回类型定义|转发函数返回类型（保留原类型）|
|示例|`auto it = v.begin();`|`decltype(v.begin()) it;`|`decltype(auto) func() { return x; }`|

### 五、使用建议

1. 日常变量声明优先用 `auto`，简化代码（如 `auto result = compute();`）。
2. 需保留精确类型（如引用、const、数组）时用 `decltype`（如模板中定义关联类型）。
3. 函数返回值需要 “原样转发” 时用 `decltype(auto)`（如包装函数、转发器）。
4. 避免过度使用自动推导：复杂场景下显式类型更易读（如 `int` 比 `auto` 更清晰时）。

这些工具是 C++ 类型系统的重要补充，尤其在泛型编程和现代 C++ 开发中不可或缺，合理使用可大幅提升代码的简洁性和可维护性。

## 常量表达式

C++ 中的**常量表达式（Constant Expression）** 是指在**编译期就能确定值**的表达式，它允许程序在编译阶段完成计算、内存分配等操作，从而提升运行时效率并增强类型安全性。C++11 引入了 `constexpr` 关键字来显式声明常量表达式，后续标准（C++14/C++17/C++20）不断扩展其能力，使其成为现代 C++ 的核心特性之一。

### 一、常量表达式的核心价值

1. **编译期计算**：将部分运行时的计算提前到编译期完成，减少程序运行时的开销。
2. **类型安全**：编译期即可可以验证表达式的有效性，避免运行时错误。
3. **优化机会**：编译器可基于常量表达式进行更深度的优化（如常量折叠、死代码消除）。
4. **支持编译期内存分配**：如 `constexpr` 数组可在编译期确定大小并分配内存。

### 二、`constexpr` 的基本用法

`constexpr` 可用于修饰**变量**、**函数**和**构造函数**，表明它们的值或返回结果可以在编译期确定。

#### 1. `constexpr` 变量

用 `constexpr` 声明的变量必须在编译期初始化，且其值必须是常量表达式。

```cpp
// 基础类型常量表达式
constexpr int max_size = 1024;  // 编译期确定值为1024
constexpr double pi = 3.1415926;

// 表达式初始化（需为编译期可计算）
constexpr int a = 10 + 20;       // 合法：10+20是编译期常量
constexpr int b = max_size / 2;  // 合法：基于其他constexpr变量

// 错误示例：运行时才能确定的值不能初始化constexpr变量
int x = 5;
// constexpr int c = x;  // 编译错误：x是运行时变量
```

**与 `const` 的区别**：

- `const` 变量仅表示 “只读”，其值可能在运行时初始化（如 `const int d = rand();`，值在运行时确定）。
- `constexpr` 变量必须在编译期确定值，是 “编译期常量” 的强化版本。

#### 2. `constexpr` 函数

`constexpr` 函数是**可以在编译期被调用并计算结果**的函数。其返回值在编译期调用时是常量表达式，在运行时调用时与普通函数一致。

#### C++11 中的限制

- 函数体只能有一条 `return` 语句（不允许复杂逻辑）。
- 参数和返回值必须是 “字面类型”（可在编译期构造的类型，如基础类型、数组、某些结构体等）。

```cpp
// C++11：简单constexpr函数
constexpr int add(int a, int b) {
    return a + b;  // 仅一条return语句
}

constexpr int sum = add(10, 20);  // 编译期调用，sum=30（常量表达式）
int x = 5, y = 6;
int runtime_sum = add(x, y);      // 运行时调用，与普通函数一致
```

#### C++14 及以后的扩展

- 允许函数体包含多条语句（条件分支、循环等）。
- 支持局部变量（但必须是 `constexpr` 或编译期可初始化）。

```cpp
// C++14：复杂constexpr函数（支持循环和分支）
constexpr int factorial(int n) {
    if (n <= 1) return 1;
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}

constexpr int f5 = factorial(5);  // 编译期计算：f5=120
```

#### 3. `constexpr` 构造函数与常量对象

对于自定义类型，`constexpr` 构造函数允许在编译期创建对象（即 “常量对象”）。

```cpp
class Point {
private:
    int x, y;
public:
    // constexpr构造函数（C++11起）
    constexpr Point(int x_, int y_) : x(x_), y(y_) {}

    // constexpr成员函数（返回成员变量）
    constexpr int getX() const { return x; }
    constexpr int getY() const { return y; }
};

// 编译期创建Point对象（常量对象）
constexpr Point origin(0, 0);
constexpr int x = origin.getX();  // 编译期获取x值（0）
```

C++20 进一步允许 `constexpr` 构造函数中包含更复杂的逻辑（如循环、条件判断）。

### 三、常量表达式的应用场景

1. **数组大小定义**：
    数组大小必须是编译期常量，`constexpr` 可动态计算大小：

    ```cpp
    constexpr int n = 5;
    int arr[factorial(n)];  // 数组大小为120（编译期确定）
    ```

2. **模板参数**：
    模板参数必须是编译期常量，`constexpr` 函数的返回值可直接作为参数：

    ```cpp
    template <int N>
    struct Buffer { char data[N]; };
    
    Buffer<add(3, 7)> buf;  // 等价于Buffer<10>，编译期确定N=10
    ```

3. **`std::array` 初始化**：
    `std::array` 的大小需编译期确定，结合 `constexpr` 可实现编译期初始化：

    ```cpp
    #include <array>
    constexpr int size = 4;
    std::array<int, size> arr = {1, 2, 3, 4};  // 编译期确定大小
    ```

4. **编译期算法**：
    复杂逻辑（如排序、查找）可通过 `constexpr` 函数在编译期完成：

    ```cpp
    // 编译期计算斐波那契数列
    constexpr int fib(int n) {
        return (n <= 1) ? n : fib(n-1) + fib(n-2);
    }
    constexpr int fib10 = fib(10);  // 编译期计算：55
    ```

### 四、常量表达式的限制

1. **字面类型要求**：参与常量表达式的类型必须是 “字面类型”（Literal Type），即：

    - 基础类型（`int`、`double` 等）、引用、指针。
    - 不含虚函数或虚基类的类，且其所有成员和基类都是字面类型。
2. **函数副作用**：`constexpr` 函数不能有副作用（如修改全局变量、I/O 操作），因为编译期执行无法产生运行时副作用。
3. **动态内存**：C++11/14 中 `constexpr` 函数不允许使用动态内存（`new`/`delete`），C++20 起允许但限制严格（编译期分配的内存必须在编译期释放）。

### 五、总结

常量表达式（`constexpr`）是 C++ 编译期编程的核心工具，它通过以下方式增强程序：

- **性能**：将计算从运行时提前到编译期，减少运行开销。
- **安全性**：编译期验证表达式有效性，避免运行时错误。
- **灵活性**：支持编译期动态计算（如数组大小、模板参数），突破了传统常量的限制。

随着 C++ 标准的演进，`constexpr` 的能力不断扩展（从简单函数到复杂逻辑），已成为现代 C++ 中编写高效、安全代码的重要手段。

# 函数

## **函数重载（Function Overloading）**

   - **函数重载**允许在同一作用域内定义多个同名函数，根据**参数列表（参数类型、数量或顺序）** 区分。
   - 返回类型不同不能作为重载依据（编译器无法仅通过返回类型区分调用）。

## **默认参数（Default Arguments）**

   - C++ 允许为函数参数指定默认值，调用时若省略该参数，编译器会自动填入默认值。
   - 默认参数必须从右向左定义（若某个参数有默认值，其右侧所有参数都必须有默认值）。

## 引用参数（Reference Parameters）

C++ 引入**引用（&）** 作为函数参数，允许函数直接操作实参本身（而非副本），替代 C 语言的指针传递，更安全且语法简洁。

- 避免大对象的拷贝（提升性能）。
- 直接修改实实参（无需指针的 `*` 和 `&` 操作）。
- 常量引用：不修改实参，避免拷贝

## Lambda 表达式（匿名函数）（C++11）

C++11 引入的**lambda 表达式**（匿名函数）是一种在代码中**就地定义匿名函数**的语法，主要用于简化 “临时性功能代码” 的编写，尤其适合作为算法的回调函数或短小的函数对象。它的核心价值是**减少代码冗余**，让逻辑更紧凑。

### 一、lambda 表达式的基本语法

lambda 表达式的完整语法结构如下：

```cpp
[capture-list] (parameter-list) mutable noexcept -> return-type {
    // 函数体
}
```

各部分含义：

- **`[capture-list]`（捕获列表）**：定义 lambda 外部的变量如何被内部访问（核心特性，后文详解）。
- **`(parameter-list)`（参数列表）**：与普通函数的参数列表一致（可省略，若为空）。
- **`mutable`（可选）**：允许 lambda 内部修改按值捕获的变量（默认不可修改）。
- **`noexcept`（可选）**：声明 lambda 不会抛出异常。
- **`-> return-type`（返回类型）**：指定返回类型（可省略，由编译器自动推导）。
- **`{函数体}`**：lambda 的执行逻辑。

### 二、最简单的 Lambda 表达式

最简化的 lambda 可以省略参数列表、返回类型，仅保留捕获列表（可为空）和函数体：

```cpp
#include <iostream>

int main() {
    // 无参数、无捕获、无返回值的lambda
    auto hello = []() { 
        std::cout << "Hello, Lambda!" << std::endl; 
    };
    
    hello();  // 调用lambda，输出：Hello, Lambda!
    return 0;
}
```

- `auto` 用于存储 lambda 表达式（lambda 的类型是编译器生成的匿名类型，无法显式写出）。
- 可直接调用，无需命名：`[]() { std::cout << "直接调用"; }();`

### 三、核心部分：捕获列表（`[capture-list]`）

捕获列表控制 lambda 如何访问**定义它的作用域中的变量**，是 lambda 与普通函数的关键区别。常见捕获方式：

|捕获方式|含义|
|---|---|
|`[]`|不捕获任何外部变量|
|`[var]`|按值捕获变量 `var`（副本，不可修改）|
|`[&var]`|按引用捕获变量 `var`（可修改原变量）|
|`[=]`|按值捕获所有使用到的外部变量|
|`[&]`|按引用捕获所有使用到的外部变量|
|`[=, &var]`|默认按值捕获，仅 `var` 按引用捕获|
|`[&, var]`|默认按引用捕获，仅 `var` 按值捕获|
|`[this]`|在类中捕获当前对象（`*this`）|

- 示例：不同捕获方式的效果

```cpp
#include <iostream>

int main() {
    int a = 10, b = 20;
    
    // 1. 按值捕获a，按引用捕获b
    auto func1 = [a, &b]() {
        // a = 100;  // 错误：按值捕获的变量不可修改（除非加mutable）
        b = 200;    // 正确：按引用捕获可修改原变量
        std::cout << "a=" << a << ", b=" << b << std::endl;  // a=10, b=200
    };
    func1();
    std::cout << "外部b=" << b << std::endl;  // 外部b被修改为200
    
    // 2. 按值捕获所有变量（a和b），并允许修改副本（mutable）
    auto func2 = [=]() mutable {
        a = 100;  // 允许修改副本（不影响外部a）
        b = 200;
        std::cout << "内部a=" << a << ", 内部b=" << b << std::endl;  // 100, 200
    };
    func2();
    std::cout << "外部a=" << a << ", 外部b=" << b << std::endl;  // 10, 200（无变化）
    
    // 3. 按引用捕获所有变量
    auto func3 = [&]() {
        a = 30;
        b = 40;
    };
    func3();
    std::cout << "外部a=" << a << ", 外部b=" << b << std::endl;  // 30, 40（被修改）
    
    return 0;
}
```

### 四、参数列表与返回类型

lambda 的参数列表和返回类型与普通函数类似，但更灵活：

1. 参数列表

- 支持普通参数、默认参数（C++14 起）、可变参数等：

    ```cpp
    // 带参数和默认参数的lambda
    auto add = [](int x, int y = 5) { 
        return x + y; 
    };
    std::cout << add(3);    // 3+5=8
    std::cout << add(3, 4); // 3+4=7
    ```

- C++14 起支持 `auto` 作为参数类型（泛型 lambda）：

    ```cpp
    // 泛型lambda（参数类型自动推导）
    auto sum = [](auto a, auto b) { 
        return a + b; 
    };
    sum(1, 2);       // 3（int+int）
    sum(3.14, 2.7);  // 5.84（double+double）
    ```

1. 返回类型

- 若函数体仅有一条 `return` 语句，返回类型可省略（编译器自动推导）：

    ```cpp
    auto multiply = [](int x, int y) { 
        return x * y;  // 自动推导返回类型为int
    };
    ```

- 若函数体有复杂逻辑（如分支返回不同类型），需显式指定返回类型：

    ```cpp
    auto divide = [](double x, double y) -> double {  // 显式指定返回double
        if (y == 0) return 0;
        return x / y;
    };
    ```

### 五、lambda 在 STL 中的典型应用

lambda 最常用的场景是作为 STL 算法的回调函数（如排序、遍历、条件判断），替代繁琐的函数对象或全局函数。

- 配合 STL 算法（如 `sort`、`for_each`）实现简洁的回调逻辑。

```cpp
#include <algorithm>
#include <vector>

int main() {
    vector<int> nums = {3, 1, 4, 1, 5};

    // 用lambda作为排序规则（降序）
    sort(nums.begin(), nums.end(), 
         [](int a, int b) { return a > b; });  // 匿名函数：比较a和b

    // 用lambda遍历输出
    for_each(nums.begin(), nums.end(), 
             [](int x) { cout << x << " "; });  // 输出：5 4 3 1 1
    return 0;
}
```

### 六、lambda 的类型与存储

- lambda 的类型是**编译器生成的匿名非 union 类类型**（称为 “闭包类型”），因此必须用 `auto` 或模板参数接收。
- 可将 lambda 存储在 `std::function`（C++11 起）中，实现更灵活的回调管理：

    ```cpp
    #include <functional>
    
    int main() {
        // 存储lambda到std::function
        std::function<int(int, int)> func = [](int a, int b) {
            return a + b;
        };
        func(2, 3);  // 5
        return 0;
    }
    ```

- 无捕获的 lambda 可隐式转换为函数指针，有捕获的则不能：

    ```cpp
    // 无捕获lambda → 函数指针
    auto lambda = [](int x) { return x * 2; };
    int (*func_ptr)(int) = lambda;  // 合法
    func_ptr(5);  // 10
    ```

### 七、注意事项

1. **生命周期问题**：按引用捕获的变量必须确保在 lambda 调用时仍有效（避免悬垂引用）：

    ```cpp
    auto get_lambda() {
        int x = 10;
        return [&x]() { return x; };  // 危险：x在函数返回后销毁，引用失效
    }
    ```

2. **`mutable` 的使用**：仅允许修改按值捕获的副本，不影响外部变量：

    ```cpp
    int x = 5;
    auto func = [x]() mutable { x++; return x; };
    func();  // 返回6（副本被修改）
    std::cout << x;  // 仍为5（外部x不变）
    ```

3. **性能**：lambda 通常与手写函数效率相同（编译器优化），但复杂捕获可能引入微小开销。

## Const 成员函数

在类的成员函数后加 `const`，表示该函数**不会修改类的成员变量**，是对成员函数的 “只读” 约束。

- 增强代码可读性（明确函数不修改对象状态）。
- 确保 `const` 对象只能调用 `const` 成员函数（安全性）。

# 其他编程范式

## 命名空间（`namespace`）

   - **C++ 特性**：避免全局命名冲突。
   - **示例**：

 ```cpp
 namespace MyLib {
	 int func() { return 42; }
 }
 int main() {
	 std::cout << MyLib::func(); // 使用命名空间
 }
 ```

## 右值引用与移动表达式（C++11）

C++11 引入**右值引用（`&&`）** 和移动语义，通过 `std::move` 将左值转为右值，允许表达式中的资源（如动态内存）被 “移动” 而非 “拷贝”，大幅优化性能。

避免表达式中临时对象的冗余拷贝（如 `a = b + c` 中，`b + c` 的结果是临时对象，可被移动到 `a`）。

- 示例：移动表达式优化

```cpp
#include <vector>
#include <utility>  // std::move

int main() {
    std::vector<int> v1(10000, 1);  // 大容器，含10000个元素

    // 差：拷贝构造，复制10000个元素（开销大）
    std::vector<int> v2 = v1;

    // 优：移动构造，仅转移资源所有权（无元素复制）
    std::vector<int> v3 = std::move(v1);  // v1变为空，v3拥有原资源
    return 0;
}
```

- 关键表达式：
- `std::move(x)`：将左值 `x` 转为右值引用，触发移动操作；
- 移动赋值：`a = std::move(b)`，资源从 `b` 移动到 `a`；
- 临时对象表达式（如 `a + b`）天然是右值，自动触发移动（若类型支持）。

## 初始化列表表达式（Initializer List）（C++11）

C++11 引入**初始化列表（`{}`）**，作为一种通用的表达式语法，统一了不同场景的初始化方式（如变量、容器、函数参数）。

- 用简洁的 `{}` 语法表示 “值的集合”，使表达式更直观，支持多种类型的初始化。
- 示例：初始化列表表达式的应用

```cpp
#include <vector>
#include <map>

// 接受初始化列表作为参数的函数
void print(std::initializer_list<int> list) {
    for (int x : list) {
        std::cout << x << " ";
    }
}

int main() {
    // 初始化容器
    std::vector<int> vec = {1, 2, 3};  // 列表初始化
    std::map<int, std::string> map = {{1, "one"}, {2, "two"}};

    // 作为函数参数
    print({4, 5, 6});  // 输出：4 5 6

    // 直接作为表达式使用
    auto list = {7, 8, 9};  // list类型为std::initializer_list<int>
    return 0;
}
```

## `nullptr` 表达式（C++11）

C++11 引入 `nullptr` 作为空指针常量，替代 C 中的 `NULL`（`NULL` 本质是 `0`），避免整数与指针的混淆：

```cpp
void func(int x) {}
void func(void* p) {}

int main() {
func(NULL);    // 调用func(int)（C中歧义）
func(nullptr); // 调用func(void*)（明确指向指针重载）
}
```

## 范围 for 表达式（C++11）

C++11 简化了容器遍历的表达式，直接迭代元素而非通过索引或迭代器：

```cpp
std::vector<int> nums = {1, 2, 3};
for (int x : nums) {  // 范围for，等价于遍历nums的每个元素
std::cout << x;
}
```

## 类型转换表达式增强

C++ 提供更安全的类型转换表达式（替代 C 的强制转换）：

- `static_cast`：编译期类型转换（如 `int`→`double`）；
- `dynamic_cast`：运行时多态类型转换（带类型检查）；
- `reinterpret_cast`：底层二进制转换（如指针→整数），比 C 的强制转换更明确。

## 结构化绑定（C++17）

 ```
std::pair<int, std::string> p = {42, "hello"};
auto [id, name] = p; // 解包
```

## 折叠表达式（C++17）

```
template<typename… Args>
void print(Args… args) {
(std::cout << … << args) << '\n'; // 折叠表达式
}
```

## 泛型编程

泛型编程（Generic Programming）是一种**独立于具体数据类型的编程范式**，核心思想是：**编写与类型无关的通用代码，通过 “参数化类型” 实现代码复用**，同时保证类型安全和高效性。C++ 是泛型编程的典型实现者，其核心工具是**模板（Template）**，标准模板库（STL）是泛型编程的经典应用。C++ 通过**函数模板**和**类模板**实现泛型，模板是 “代码生成器”—— 编译器根据传入的具体类型，自动生成对应版本的函数或类。

C++ 标准模板库（STL）核心组件（容器、算法、迭代器）全基于模板实现：

- **容器（Containers）**：如 `vector<T>`、`list<T>`、`map<K, V>`，通过类模板支持任意元素类型。
- **算法（Algorithms）**：如 `sort`、`find`，通过函数模板可操作任意容器（依赖迭代器）。
- **迭代器（Iterators）**：作为容器与算法的 “桥梁”，模拟指针行为，使算法独立于具体容器类型。
