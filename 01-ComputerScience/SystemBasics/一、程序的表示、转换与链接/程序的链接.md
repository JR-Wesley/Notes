---
dateCreated: 2025-08-02
dateModified: 2025-08-02
---

一个大的程序往往会分成多个源程序文件来编写, 因而需要对各个不同源程序文件分别进行编译或汇编, 以生成多个不同的目标代码文件, 这些目标代码文件中包含指令、数据和其他说明信息。此外, 在程序中还会调用一些标准库函数。为了生成一个可执行文件, 需要将所有关联到的目标代码文件, 包括用到的标准库函数目标文件, 按照某种形式组合在一起, 形成一个具有统一地址空间的可被加载到存储器直接执行的程序。这种**将一个程序的所有关联模块对应的目标代码文件结合在一起, 以形成一个可执行文件的: 过程称为链接**。现在由专门的链接程序 (linkeer, 也称为链接器) 来实现。

# 4.1 编译、汇编和静态链接

链接概念早在高级编程语言出现之前就已存在。例如，在汇编语言代码中，可以用一个标号表示某个转移**目标指令的地址** (即给定了一个标号的定义), 而在另一条转移指令中引用该标号：也可以用一个标号表示某个**操作数的地址**，而在某条使用该操作数的指令中引用该标号。因而，在对汇编语言源程序进行汇编的过程中，对每个标号的引用，需要找到该标号对应的定义，建立每个标号的引用和其定义之间的关联关系，从而在引用标号的指令中正确地填入对应的地址码字段，以保证能访问到所引用的符号定义处的的信息。

在高级编程语言出现之后，程序功能越来越复杂，规模越来越大，需要多人开发不同的程序模块。在每个程序模块中，包含一些变量和子程序 (函数) 的定义。这些**被定义的变量和子程序的起始地址就是符号定义**，子程序 (函数或过程) 的调用或者在表达中使用变量进行计算就是**符号引用**。某一个模块中定义的符号可以被另一个模块引用，因而最终必须通过链接将程序包含的所有模块合并起来，合并时须在符号引用处处填入定义处的地址。

## 一、编译和汇编

将高级语言源程序文件转换为可执行目标文件通常分为**预处理、编译、汇编和链接**四个步骤。前面三个步骤用来对每个模块 (即源程序文件) 生成**可重定位目标文件 (relocatable object file)**。最后一个步骤为链接,用来将若干可重定位目标文件 (可能包括若干标准库函数目标模块) 组合起来, 生成一个**可执行目标文件 (executable object file)**。有时将可重定位目标文件和可执行目标文件分别简称可重定位文件和可执行文件。

### 以 GCC (GNU Compiler Collection) 处理 C 语言程序为例来说明处理过程

假设我们有一个简单的 C 语言源文件 `hello.c`：

```c
#include <stdio.h>

#define PI 3.14159

int main() {
    printf("Hello, World! PI is %.5f\n", PI);
    return 0;
}
```

`cpp`, `cc1`, `as`, `ld` 是 GCC (GNU Compiler Collection) 在将 C/C++ 源代码转换为可执行程序的过程中，背后调用的**核心工具**。它们分别对应编译流程的四个主要阶段：预处理、编译、汇编和链接。

虽然我们通常直接使用 `gcc` 或 `g++` 命令，但这些命令实际上是**驱动程序 (driver)**，它们会根据需要自动调用这些底层工具来完成具体任务。使用 `gcc` 时可以用 `-v` 查看每一步的处理过程。如果想要得到每一步的结果，也可以分别调用处理。

---

#### 1. 预处理 (Preprocessing)

`cpp` - C/C++ 预处理器 (C/C++ Preprocessor)

**作用**：
预处理阶段主要处理源代码中以 `#` 开头的预处理指令（如 `#include`, `#define`, `#ifdef` 等）。具体任务包括：
* **包含头文件**：将 `#include <stdio.h>` 这样的指令替换为实际的头文件内容。
* **宏展开**：将宏定义（如 `PI`）替换成其定义的值。
* **条件编译**：根据 `#ifdef`, `#ifndef` 等指令决定是否包含某段代码。
* **删除注释**：移除源代码中的注释。
* **处理 `#pragma` 指令**。

**GCC 命令**：

```bash
gcc -E hello.c -o hello.i

cpp hello.c > hello.i
```

* `-E` 选项告诉 GCC 只进行预处理。
* `-o hello.i` 指定输出文件名为 `hello.i`（通常为 `.i` 后缀）。

**结果**：
生成的 `hello.i` 文件是一个经过预处理的 C 语言源代码文件。它包含了 `stdio.h` 的所有内容，并且 `PI` 已被替换为 `3.14159`，注释也被删除。这个文件仍然是人类可读的 C 代码。

---

#### 2. 编译 (Compilation)

`cc1` - C 编译器 (C Compiler) / `cc1plus` - C++ 编译器

**作用**：
* 将预处理后的 C 语言源代码（`.i` 文件）解析、分析（词法、语法、语义），进行优化，最终翻译成特定目标架构的**汇编语言**代码（`.s` 文件）。
* 编译阶段将预处理后的 C 语言源代码 (`hello.i`) 翻译成特定于目标机器的**汇编语言**代码。这个过程包括：
* 语法分析、语义分析。
* 优化代码（可选，取决于优化选项）。
* 生成与目标处理器架构（如 x86_64）对应的汇编指令。
特点：
* `cc1`/`cc1plus` 通常是**内部工具**，不直接提供给用户在命令行调用。普通用户通过 `gcc`/`g++` 命令并使用 `-S` 选项来触发编译阶段。
* 你可以通过 `gcc -v`（verbose）选项查看 `gcc` 内部是如何调用 `cc1` 的。

**GCC 命令**：

```bash
gcc -S hello.i -o hello.s
```

* `-S` 选项告诉 GCC 只进行到编译阶段，生成汇编代码。
* `-o hello.s` 指定输出文件名为 `hello.s`（通常为 `.s` 后缀）。

> **注意**：你也可以直接从 `.c` 文件开始编译，GCC 会自动先进行预处理再编译：
> ```bash
> gcc -S hello.c -o hello.s
> ```

**结果**：
生成的 `hello.s` 文件是汇编语言源代码文件。它包含的是人类可读的、但与机器指令一一对应的汇编指令（如 `mov`, `call`, `push` 等），针对特定的 CPU 架构。

---

#### 3. 汇编 (Assembly)

`as` - 汇编器 (Assembler)

`as` 是 GNU Binutils (Binary Utilities) 包的一部分，通常称为 **GNU Assembler**。

**作用**：
汇编阶段将汇编语言源代码 (`hello.s`) 翻译成机器可以直接执行的**目标代码**（Object Code）。目标代码是二进制格式的机器指令，但它还不是可以直接运行的完整程序。
* 汇编器 (`as`) 将每条汇编指令转换成对应的机器码（二进制）。
* 生成的目标文件（`.o` 或 `.obj`）包含了机器码、数据、符号表（函数名、变量名等）以及重定位信息。

**GCC 命令**：

```bash
gcc -c hello.s -o hello.o

as hello.s -o hello.o
```

* `-c` 选项告诉 GCC 进行到汇编阶段，生成目标文件，但不进行链接。
* `-o hello.o` 指定输出文件名为 `hello.o`（通常为 `.o` 后缀）。

> **注意**：你也可以直接从 `.c` 或 `.i` 文件开始汇编，GCC 会自动完成前面的步骤：
> ```bash
> gcc -c hello.c -o hello.o
> ```

**结果**：
生成的 `hello.o` 文件是一个**目标文件**（Object File）。它是二进制文件，包含了 `main` 函数的机器码，但其中对 `printf` 函数的调用只是一个**未解析的符号引用**（因为 `printf` 的定义在标准库中，不在这个文件里）。目标文件还包含了重定位信息，告诉链接器将来如何调整地址。

汇编的功能是将编译生成的汇编语言代码转换为机器语言代码。因为通常最终的可执行目标文件由多个不同模块对应的机器语言目标代码组合而形成,所以,在生成单个模块的机器语言目标代码时,不可能确定每条指令或每个数据最终的地址,也即,单个模块的机器语言目标代码需要重新定位, 因此, 通常把汇编生成的机器语言目标代码文件称为可重定位目标文件。

---

#### 4. 链接 (Linking)

`ld` - 链接器 (Linker)

`ld` 也是 GNU Binutils 包的核心组件，称为 **GNU Linker**。

**作用**：
链接阶段将一个或多个目标文件（`.o`）以及所需的库文件（如标准 C 库 `libc.a` 或 `libc.so`）组合起来，形成一个单一的、完整的**可执行文件**。主要任务包括：
* **符号解析**：找到所有未定义符号（如 `printf`）的实际定义。
* **重定位**：将各个目标文件中的代码和数据段合并，并为所有符号（函数、变量）分配最终的内存地址。
* **处理库函数**：将程序中用到的库函数（如 `printf`）的代码链接进来（静态链接）或建立动态链接信息（动态链接）。

`ld` 手动调用非常复杂，需要手动指定启动代码（`crt*.o`）、C 标准库（`-lc`）和动态链接器路径。

**GCC 命令**：

```bash
gcc hello.o -o hello
```

* 这是最常见的链接命令。`gcc` 会自动调用链接器 (`ld`)。
* `hello.o` 是输入的目标文件。
* `-o hello` 指定最终的可执行文件名为 `hello`（在 Windows 上通常是 `hello.exe`）。

> **注意**：GCC 通常允许你一步到位：
> ```bash
> gcc hello.c -o hello
> ```
> 这条命令会依次执行预处理、编译、汇编和链接四个步骤，直接生成可执行文件 `hello`。

**结果**：
生成的 `hello` 文件就是一个**可执行目标文件**。它包含了程序运行所需的所有机器代码（包括 `main` 和 `printf` 等库函数的代码或链接信息），并且已经完成了地址分配，操作系统可以直接加载并运行它。

---

#### 总结

|工具|阶段|主要功能|输入文件|输出文件|所属包/说明|
|---|---|---|---|---|---|
|**`cpp`**|预处理|处理 `#include`, `#define`, 宏展开等|`.c`, `.cpp`|`.i`, `.ii`|GCC (预处理器)|
|**`cc1`**|编译 (C)|C 源码 -> 汇编代码|`.i`|`.s`|GCC (内部编译器, C 专用)|
|**`cc1plus`**|编译 (C++)|C++ 源码 -> 汇编代码|`.ii`|`.s`|GCC (内部编译器, C++ 专用)|
|**`as`**|汇编|汇编代码 -> 目标代码 (机器码)|`.s`|`.o`|GNU Binutils (汇编器)|
|**`ld`**|链接|目标文件 + 库 -> 可执行文件|`.o`, `.a`, `.so`|可执行文件, `.so`, `.a`|GNU Binutils (链接器)|

**总结流程图**：

```
hello.c (源代码)
     |
     |  预处理 (gcc -E)
     V
hello.i (预处理后的C代码)
     |
     |  编译 (gcc -S)
     V
hello.s (汇编代码)
     |
     |  汇编 (gcc -c)
     V
hello.o (目标文件/二进制代码)
     |
     |  链接 (gcc)
     V
hello (可执行文件)
```

当你运行 `gcc hello.c -o hello` 时，GCC 驱动程序会按顺序调用这些工具（`cpp` -> `cc1` -> `as` -> `ld`），最终生成可执行文件 `hello`。通过这四个步骤，GCC 成功地将人类可读的高级 C 语言源代码转换成了计算机可以执行的二进制程序。

### 可执行目标文件的生成

## 目标文件格式

## 符号表与符号解析

### ELF 目标文件格式

### 可重定位目标文件格式

### 可执行目标文件格式

### 4.2.4 可执行文件的存储器映像

计算机内存的存储区域划分是程序运行时的基础，其布局由编译器、链接器和操作系统共同决定。通常，一个运行中的程序（进程）的内存空间会被划分为多个功能不同的区域，**堆（Heap）** 和**栈（Stack）** 是其中最核心的动态区域，其他还包括代码区、数据区等。

### 典型的内存区域划分（从低地址到高地址）

以下是内存布局的经典划分（不同系统可能略有差异，但核心逻辑一致）：

#### 1. 代码区（Text Segment）存放 “执行指令”

- **位置**：通常在内存低地址区域。
- **核心作用**：存储程序编译后的二进制机器指令（CPU 可直接执行的操作码），是程序的 “执行逻辑” 所在。例如，函数中的 “赋值”“循环”“判断” 等操作，最终都会转化为代码区的指令。
- **为什么需要**：
    - 指令需要被 CPU 反复读取执行，因此代码区需保证 “只读性”（防止程序意外修改指令导致逻辑混乱）；
    - 多个进程运行同一程序时（如同时打开两个浏览器窗口），可共享同一份代码区（节省内存，避免重复存储）。
- **特性**：
    - 只读（防止程序意外修改指令）；
    - 可共享（多个进程运行同一程序时，可共享同一份代码区，节省内存）；
    - 大小在编译时就已确定（指令数量固定）。

#### 2. 数据区（Data Segment）存放 “长期存在的变量”

数据区用于存储**全局变量**和**静态变量**（生命周期与程序一致，随程序启动而分配，随程序退出而释放），又细分为：

- **初始化数据区（Initialized Data）**：
    
    - 存放 “已显式赋值” 的全局变量和静态变量（如 `int global = 10;` 或 `static int s = 20;`）。
    - 作用：程序启动时直接加载这些变量的初始值，无需运行时再初始化，提高效率。
- **未初始化数据区（BSS Segment）**：
    
    - 存放 “未显式赋值” 的全局变量和静态变量（如 `int global;` 或 `static int s;`）。
    - 作用：操作系统会在程序启动时自动将该区域的变量初始化为 0（或 NULL），避免 “垃圾值” 导致程序异常，同时节省编译后的文件大小（无需存储初始值）。

#### 3. 堆（Heap）存放 “动态创建的数据”

- **位置**：位于数据区上方，从低地址向高地址**动态增长**。
- **核心作用**：用于存储程序运行时 “动态分配” 的内存（大小不确定或需要长期存在的数据）。例如：
    - 程序运行中根据用户输入创建的数组（如 `int[] arr = new int[n];`，`n` 由用户输入决定）；
    - 生命周期超过函数调用的对象（如 C++ 中 `new` 创建的对象，需要手动 `delete` 才释放）。
- **特性**：
    - 大小不固定，可随动态分配扩展（受限于系统总内存）；
    - 由程序员手动管理（C/C++）或垃圾回收机制（Java/Python）自动管理；
    - 内存空间不连续，分配时需要查找空闲块，效率低于栈。
- **为什么需要**：
    - 栈的大小固定且较小，无法满足 “动态大小”“长期存在” 的数据需求；
    - 堆的大小灵活（受限于系统总内存），支持按需分配，适配复杂场景（如动态数据结构、大型对象）。

#### 4. 栈（Stack）### 存放 “临时数据”

- **位置**：位于内存高地址区域，从高地址向低地址**动态增长**（与堆的增长方向相反）。
- **核心作用**：为函数调用提供 “临时存储空间”，主要存储：
    - 函数的局部变量（如 `int a = 5;`，仅在函数执行时存在）；
    - 函数参数（传给函数的输入值，如 `func(10, 20)` 中的 `10` 和 `20`）；
    - 返回地址（函数执行完后，CPU 需回到的原代码位置，确保程序流程连续）。
    - 栈帧信息（维护函数调用的上下文）。
- **特性**：
    - 由编译器自动分配和释放（函数进入时压栈，退出时弹栈）；
    - 内存连续，分配效率极高（仅需移动栈指针）；
    - 大小固定（通常几 MB，超出会导致栈溢出）。
- **为什么需要**：
    - 函数调用是程序执行的基本单元，临时数据需快速创建和销毁，栈的 “自动管理”（编译器控制压栈 / 弹栈）和 “连续内存” 特性可实现极高效率（纳秒级操作）；
    - 避免临时数据占用堆的资源（堆分配效率低）。

#### 5. 命令行参数与环境变量区

- **位置**：通常在栈的顶部（更高地址处）。
- **核心作用**：存储程序启动时的外部输入，包括：
    - 命令行参数（如 `python script.py arg1 arg2` 中的 `arg1` `arg2`，供程序根据参数调整行为）；
    - 环境变量（如系统路径 `PATH`、用户目录 `HOME` 等，让程序能获取系统配置）。
- **为什么需要**：程序并非孤立运行，需与用户、系统交互，该区域是 “外部信息传入程序” 的通道。

### 核心区域的关系与特点

- **地址增长方向**：堆从低地址向高地址 “向上长”，栈从高地址向低地址 “向下长”，两者之间有大量空闲内存，避免冲突。
- **生命周期**：
    - 代码区、数据区：随程序启动存在，直到程序退出。
    - 堆：手动分配后存在，直到手动释放（或 GC 回收）。
    - 栈：仅在函数调用期间存在，函数退出后自动释放。
- **管理方式**：栈由编译器自动管理，堆由程序员（或 GC）手动管理，数据区和代码区由操作系统在程序加载时初始化。

### 举例说明

```c
int global_var; // 未初始化全局变量 → BSS区
int init_global = 100; // 初始化全局变量 → 初始化数据区

int main() {
    int local_var = 20; // 局部变量 → 栈
    static int static_var = 30; // 静态变量 → 初始化数据区
    int* heap_ptr = malloc(100); // 动态分配内存 → 堆
    free(heap_ptr); // 释放堆内存
    return 0;
}
```

总结：内存区域的划分是为了高效管理不同类型的数据（指令、全局变量、临时变量、动态数据等），堆和栈作为动态区域，分别承担 “长期灵活存储” 和 “临时快速存储” 的角色，与其他区域共同支撑程序的运行。

## 符号表和符号解析

### 符号和符号表

### 符号解析

### 与静态库的链接

## 4. 重定位

### 重定位信息

### 重定位过程

## 4.5 动态链接

# 动态链接与静态链接

这是一个非常好的问题，它涉及到 C++ 程序的组织、编译和链接方式。我们来逐一解释。

## 1. 静态库 (Static Library) vs. 动态库 (Dynamic Library)

这两者是**库文件**（Library Files）的不同形式，它们包含了预先编译好的代码（函数、类等），供其他程序链接和使用。主要区别在于**链接的时机**和**库代码的存放位置**。

| 特性 | 静态库 (Static Library) | 动态库 (Dynamic Library) |
| :--- | :--- | :--- |
| **文件扩展名** | Windows: `.lib` <br> Linux/macOS: `.a` (Archive) | Windows: `.dll` (Dynamic Link Library) <br> Linux: `.so` (Shared Object) <br> macOS: `.dylib` |
| **链接时机** | **编译时链接 (Link Time)** | **运行时链接 (Run Time)** |
| **链接过程** | 在编译你的程序时，链接器 (`linker`) 会将静态库中**被用到的代码**直接**复制**到你的最终可执行文件 (`exe`/`out`) 中。 | 你的可执行文件只包含一个**引用**（符号），指向动态库。程序运行时，操作系统**动态链接器/加载器**才将所需的动态库加载到内存，并建立连接。 |
| **可执行文件大小** | **较大**，因为它包含了所有用到的库代码。 | **较小**，因为它不包含库代码本身。 |
| **内存占用** | 多个使用同一静态库的程序运行时，每个程序都有一份库代码的副本，**内存占用高**。 | 多个程序可以**共享**同一份动态库在内存中的副本，**节省内存**。 |
| **更新库** | 更新库后，必须**重新编译和链接**所有使用该库的程序。 | 更新库文件（`.dll`, `.so`）后，只要接口不变，**无需重新编译**使用它的程序，重启程序即可使用新版本。 |
| **部署** | 只需分发可执行文件。 | 需要同时分发可执行文件和它所依赖的动态库文件。 |
| **启动速度** | 略快，因为代码已在可执行文件中。 | 略慢，因为需要加载和链接动态库。 |
| **依赖性** | 无外部库文件依赖。 | 有外部库文件依赖，如果库缺失，程序无法启动（"DLL Hell" 问题）。 |
| **示例** | `libstdc++.a` (GCC 的静态 C++ 标准库), `libcmt.lib` (MSVC 静态 C 运行时) | `libstdc++.so` (GCC 的动态 C++ 标准库), `msvcp140.dll` (MSVC 动态 C++ 运行时), `kernel32.dll` |

**简单比喻**:
*   **静态库**: 就像你写一篇文章时，把所有引用的段落都**复制粘贴**到了文章末尾。文章独立，但很长。
*   **动态库**: 就像你在文章里写了一个**脚注**，写着“详见《某本书》第 X 页”。文章本身很短，但需要那本书在手边才能完整阅读。
非常好的问题！这涉及到实际开发中的决策和底层机制。我们来详细解答。

## 如何确定该使用静态库还是动态库？

选择静态库还是动态库没有绝对的对错，取决于你的具体需求和场景。以下是关键的决策因素：

### 选择 **静态库 (.a, .lib)** 的场景

1.  **追求极致的独立性和部署简单性**:
    *   **场景**: 你需要分发一个独立的可执行文件，不希望用户安装任何额外的依赖库。
    *   **优点**: 只需一个 `.exe` 文件，用户双击即可运行，避免了“DLL Hell”（依赖库缺失或版本冲突）。
    *   **例子**: 小型工具软件、嵌入式系统、某些游戏发行版。

2.  **性能敏感，且希望最小化运行时开销**:
    *   **场景**: 对启动时间和函数调用速度有极致要求，且库代码不会被多个程序共享。
    *   **优点**: 消除了动态链接的加载和符号解析开销。函数调用是直接的，没有间接跳转。
    *   **注意**: 现代动态链接器优化得很好，这种差距通常很小。

3.  **库非常小，或使用频率极低**:
    *   **场景**: 你有一个小的、特定功能的库，只有你的一个程序使用。
    *   **优点**: 避免了管理一个独立的 `.dll`/`.so` 文件的麻烦，即使它被复制到可执行文件中也增加不了多少体积。

4.  **避免动态库版本管理的复杂性**:
    *   **场景**: 你无法控制目标环境，或者不希望因为系统更新了某个动态库而导致你的程序行为改变或崩溃。
    *   **优点**: “冻结”了库的版本，程序行为完全确定。

### 选择 **动态库 (.so, .dll, .dylib)** 的场景

1.  **代码共享和节省内存**:
    *   **场景**: 多个应用程序（或同一程序的多个实例）都需要使用同一个库。
    *   **优点**: 操作系统可以将库的代码页在内存中共享，**显著减少整体内存占用**。这是操作系统级库（如 C/C++ 运行时、GUI 库）几乎总是动态库的主要原因。

2.  **模块化和插件架构**:
    *   **场景**: 你想实现一个支持插件的程序，或者希望将大型程序拆分成独立的模块，可以独立更新。
    *   **优点**: 可以在程序运行时**动态加载** (`dlopen`/`LoadLibrary`) 和卸载库。更新某个模块（如一个插件）时，只需替换对应的 `.dll`/`.so` 文件，无需重新编译主程序。
    *   **例子**: Web 浏览器插件、图像处理软件的滤镜、游戏模组。

3.  **减小可执行文件体积**:
    *   **场景**: 你的程序很大，或者分发带宽/存储空间是瓶颈。
    *   **优点**: 可执行文件本身很小，库文件可以单独下载或预装。

4.  **热更新 (Hot Update)**:
    *   **场景**: 服务器程序需要在不中断服务的情况下更新某些功能模块。
    *   **优点**: 可以卸载旧的动态库模块，加载新的模块，实现功能更新。

5.  **遵守许可协议**:
    *   **场景**: 你使用的第三方库要求以动态链接方式分发（例如，某些 LGPL 许可的库）。
    *   **优点**: 避免将你的专有代码与该库的代码“静态链接”在一起，从而可能避免你的整个程序也必须开源。

**决策流程图 (简化)**:

```
你的库会被多个程序使用吗？ -- 是 --> 强烈推荐 **动态库**
                             |
                             否
                             |
你的程序需要独立分发，不希望有外部依赖吗？ -- 是 --> 推荐 **静态库**
                                          |
                                          否
                                          |
你希望实现插件或模块热更新吗？ -- 是 --> 必须 **动态库**
                             |
                             否
                             |
性能/内存/体积哪个是首要瓶颈？ --> 内存/体积优先 --> **动态库**
                                 --> 性能/独立性优先 --> **静态库**
```

## `printf`, `scanf`, `fopen` 和 C++ 标准库到底是静态还是动态链接？

这**完全取决于你的编译器、编译选项和目标平台**。没有一个固定的答案。

### 如何确定？

1.  **查看编译器/链接器选项**:
    *   **GCC / Clang (Linux/macOS)**:
        * 默认通常是**动态链接**到 `libc` (C 库) 和 `libstdc++` (C++ 库)。
        * 使用 `-static` 选项会强制**静态链接**所有库（包括 C/C++ 运行时）。
        * 使用 `-static-libgcc -static-libstdc++` 可以只静态链接 C/C++ 标准库，而其他库（如系统库）仍动态链接。
    *   **MSVC (Visual Studio)**:
        * 在项目设置中，可以配置 C/C++ 运行时库：
            *   `/MD` 或 `/MDd` (Debug): 链接**动态**的多线程 C 运行时库 (`msvcrt.dll` / `ucrtbase.dll` 等)。
            *   `/MT` 或 `/MTd` (Debug): 链接**静态**的多线程 C 运行时库 (`libcmt.lib` / `libcmtd.lib`)。
        *   C++ 标准库 (`std::vector`, `std::string` 等) 的动态/静态链接通常与 C 运行时库的设置保持一致。

2.  **检查生成的可执行文件**:
    *   **Linux/macOS**: 使用 `ldd <your_executable>` (Linux) 或 `otool -L <your_executable>` (macOS) 命令。如果输出中包含 `libc.so.6`, `libstdc++.so.6` 等，说明是动态链接。如果这些库不在列表中，很可能是静态链接（或被其他动态库间接依赖）。
    *   **Windows**: 使用 `dumpbin /dependents <your_executable.exe>` 命令。如果输出中包含 `msvcr140.dll`, `vcruntime140.dll`, `ucrtbase.dll` 等，说明是动态链接。如果这些 DLL 不在依赖列表中，则很可能是静态链接。

3.  **文件大小**:
    * 一个只调用了 `printf` 的简单 "Hello World" 程序：
        *   **动态链接**: 可执行文件可能只有几 KB 到几十 KB。
        *   **静态链接**: 可执行文件可能达到几百 KB 甚至上 MB（因为它包含了整个 `libc` 的相关部分）。

### 一般情况下的默认行为

*   **Linux**: 绝大多数发行版和编译器默认使用**动态链接**。`libc` (`glibc` 或 `musl`) 和 `libstdc++` 通常作为系统级动态库 (`*.so`) 存在。
*   **Windows**: Visual Studio 的默认项目模板通常使用 `/MD` (动态链接)。这意味着 `printf` 等 C 函数和 `std::vector` 等 C++ 类的实现代码位于 `msvcpXXX.dll` 和 `vcruntimeXXX.dll` 等文件中，你的 `.exe` 文件在运行时需要这些 DLL。
*   **macOS**: 类似于 Linux，通常使用**动态链接**，C/C++ 运行时是系统的一部分。

**总结**:
`stdio.h` 中声明的 `printf` 和 `<vector>` 中定义的 `std::vector` 的**实现代码**，在你编译程序时，要么被**复制**进你的可执行文件（静态链接），要么你的可执行文件保留一个**引用**，在程序启动时由操作系统**加载**对应的动态库文件（动态链接）。具体是哪种方式，由你的**编译和链接命令**决定。现代开发中，**动态链接是更常见的默认选择**，因为它能实现代码共享、节省内存和便于系统级更新。
