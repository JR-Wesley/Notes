---
dateCreated: 2020-12-27
dateModified: 2024-12-13
---
# Verilog 和 SV

标识符是代码中对象的唯一名字，标识符只可以由字母、下划线、数字和美元符号 “$”构成,并且只能由字或下划线开头。关键字是 Verilog 预定义的，用于构建代码结构的特殊标识符，在 Verilog 中所有关键字都是全部小写的。代码中用户定义的标识符不能与关键字相同。

## 值、数和字面量

在 Verilog 中，线网和变量可取的基本值有四个:

- 0，表示逻辑 0、低电平、条件假。
- 1，表示逻辑 1、高电平、条件真。
- x 或 X，表示未知的逻辑值。
- z 或 Z，表示高阻态。
有些数据类型可以取全部 4 个值 (称为四值)，而有些数据类型仅能取 0 和 1 两个值 (称为二值)。常数包括整型常数、浮点常数，字面量包括时间字面量、字符串字面量、结构字面量和数组字面量。
- 整型
无符号高位填充 0/x/z。位宽超过指定位宽则舍弃高位。无位宽时由赋给的对象决定
- 浮点型
IEEE754 标准的双精度浮点，可以用小数或科学计数。FPGA 编译工具一般不支持浮点常数参与实时运算，但支持浮点常量在编译期的运算。
- 时间和字符串常数
时间常数用于仿真验证。字符串型以 ASCII 表示，可以赋值给整型，左侧字符为高位。

```verilog
[-]<位宽>'[s|S]<进制标识><数值>
-3'sd2
'1
// 有符号表示

3.14159
2.1ns
"hello"
```

## 变量

变量是抽象的值存储单元，一次赋值之后，变量将保持该值直到下一次赋值。变量使用“过程”中的赋值语句对其赋值，变量的作用类似于触发器，不过是否形成触发器取决于代码上下文。变量一般由过程赋值驱动，并且不能在多个过程块中被驱动。有以下形式：

1. 整形
- bit，二值，默认无符号，常用测试代码。
- logic，四值，默认无符号。
- reg，四值，默认无符号
1. 定长整形
- byte、shortint、int、longint，二值，分别为 8 位、16 位、32 位和 64 位，默认有符号。
- integer，四值，32 位，默认有符号。
- time，四值，64 位，默认无符号。
1. 浮点型
- shortreal、real，遵循 IEEE 754 标准表达的浮点小数，分别为 32 位和 64 位。
- realtime，同 real。
1. 数组、结构、枚举（复合类型，前面三者为简单类类型）

## 参数和常量

参数和常量在运行时值不变。在标准中，参数也是一种常量，不过参数常常用来指定模块、接口的数据位宽等，因而得名。包括以下类型：

- parameter，可以被模块外部修改的参数，在模块实例化时修改或由 defparam 关键字修改。
- localparam，不能被模块外部修改的参数。
- specparam，专用于指定时序、延迟信息的参数。
- 常量 const，类似于 localparam，但可以在仿真期间更改值。
还可以定义参数化的数据类型，如：

```verilog
parameter DW = 24;
parameter type TData = logic signed [DW - 1 : 0];
parameter type LTData = logic signed [2 * DW - 1 : 0];
TData x1, x2;
LTData px;
```

常量

在 Verilog 中，常量可以分为三种：整型、实型和字符串型。

1. 整型：可以是十进制、十六进制或八进制的整数，例如 10、-10、64'hff012。
2. 实型：可以是十进制或科学计数法表示的实数，例如 3.5、3.5_1e2。
3. 字符串型：是一串字符，必须用双引号括起来。字符串型主要用于显示某些信息。

变量

Verilog 中的变量有多种类型，最基本的是线网型（Net type）和寄存器型（Register type）。

1. 线网型（Net type）：用于表示标准的互连线，例如 wire a ; wire [4:0] a,b;。
2. 寄存器型（Register type）：是一个抽象的存储单元，可以取任意长度无符号数，默认值为 X。例如 reg [3:1] MyMem[63:0]。

寄存器型变量可以进一步细分为：

- reg 型变量：可以取任意长度无符号数，默认值为 X。
- integer 型变量：整数寄存器，可以存储正、负整数，其最少可以容纳 32 位数，无法按位访问。
- time 型变量：用于存储一个 64 位时间值（无符号），单位有系统指定。
- real 型变量：实数型时间寄存器。

在 Verilog 中，parameter 可以被定义为以下数据类型：

1. 整数类型：包括有符号和无符号整数，如 `integer` 和 `reg signed` 等。
2. 实数类型：包括实数和双精度实数，如 `real` 和 `realtime` 等。
3. 时间类型：包括时间和时间精度，如 `time` 和 `timescale` 等。
4. 字符串类型：用于保存字符串，如 `string` 等。
需要注意的是，parameter 在定义时必须指定一个初始值，否则会产生编译错误。此外，parameter 的值在编译时被解析并替换为相应的值，因此它们不能被修改或重新分配。

## 类型与位宽转换

常见的几种隐式转换的规则：

- 从整数转换为浮点，保持值意不变。
- 从浮点转换为整数，会四舍五入处理。
- 等长的有符号与无符号之间，直接位对位赋值（所以最高位为 1 时，表达的值意会发生变化）。
- 从长数转换为短数，无论左右值有无符号，直接舍弃高位。
- 从短数转换为长数，如果短数为有符号数，高位填充符号位，否则填充 0。
显示转换：
- \$cast() 函数用于转换并赋值\$cast(a,b),将把 b 转换为 a 的类型并赋值给 a。\$cast() 函数带有返回值，返回 0 表示无法转换，否则表示转换成功。\$cast() 函数不能被综合，仅可用于仿真测试代码。
- \\$signed(a)、\\$unsigned(a) 函数将 a 转换为有符号或无符号，可被综合，有无符号的转换并不对 a 进行任何操作，实际影响的是相关操作符或位宽转换时高位填充什么。

```verilog
logic [3:0] a = 4'he;
logic [5:0] e = 6'($signed(a)); // a 转为有符号数，扩展高位1，然后赋给（默认无符号）e为6'b111110
logic signed [5:0] g = 4’sd5 * $signed(a); // a转为有符号数-2，乘5赋给有符号g，结果-10
```

## 操作

![[操作符.png|FPGA/assets/数字电路/操作符.png]]

有一些规则：

- 位选取、位拼接、流运算的结果为无符号数，无论操作数是否有符号。
- 仅当两个整型操作数均为有符号数时，比较按有符号进行，否则按无符号进行。
比较 (含相等、不等) 运算：
- 如果操作数中有浮点数，则另一个将被转换为等值浮点数进行比较。
- 仅当两个整型操作数均为有符号数时，比较按有符号进行，否则按无符号进行。
- 如果两个整型操作数位宽不一致，短操作数将被补充高位。
- 逻辑非、与、或、隐含和等价运算，操作数为 0 等价于 1'b0（假），操作数非 0 等价于 1'b1（真）。
- 算数和按位逻辑浮点和符号规则同上
- **注意：四则运算，若不直接赋值，结果为二者较长的位，只有直接赋值时才扩展为赋值的位宽。**
- 流操作符：用于将操作数按位、按几位一组或按元素重新组织次序
- 缩减操作符：将操作数中的所有位逐个进行逻辑运算。其中异或缩减和同或缩减的作用相当于检测操作数中 1 的个数是奇 数或偶数。
- 算数移位>>>会根据符号位来填充；逻辑移位则直接移动。
- 比较、通配比较要根据 xz 的情况

## Let

let 语句用来定义表达式模板，带有简单的端口列表，可理解为带参数的表达式，可在其他表达式里使用它。let 语句有作用域,而带参数的\`define 则是全局有效的。如：

```verilog
let max(a, b) = a > b ? a : b;
logic a, b, c;
c = max(a, b);
```

## 结构和联合（略）
## 数组（待

## 赋值、过程和块

赋值用来驱动**线网或变量**，驱动线网可理解为构建线网的连接，驱动变量则是赋予变量新的值。Verilog 中赋值主要有两种：

1. 持续赋值，持续赋值使得线网持续接收右值，相当于直接连接到组合逻辑的输出。左值只能是线网
2. 过程赋值，只是在特定事件发生时更新变量的值，而变量则会保持该值直到下一次更新。左值只能是变量。
过程赋值只能位于过程中。过程是受一定条件触发而执行的代码结构，在 Verilog 中，有以下几种过程。
3. initial，在启动时开始，多用于仿真。
4. always
- always 过程，可指定或不指定触发事件。不指定触发事件时，从启动时开始周而复始地执行。指定触发事件时，在事件发生时执行。
- always_comb 过程，专用于描述组合逻辑，在过程内的语句所依赖的任何一个值发生变化时执行，输出随着输入的变化而立即变化，正是组合逻辑的行为。
- always_latch 过程，专用于描述锁存器逻辑，由指定的线网或变量的值触发内部语句执行。在 FPGA 中应避免出现锁存器。
- always_ff 过程，专用于描述触发器逻辑 flip-flop，当指定的线网或变量出现指定跳沿时执行。
1. final 过程，在仿真结束时执行一次。
2. task/ function
Verilog 使用块组合多条语句，块有两种：
3. 顺序块，使用 begin-end 包裹，其中的多条语句是逐条执行的。
4. 并行块，使用 fork-join 包裹，其中的多条语句是同时执行的。
顺序块是可综合的，而并行块一般是不可综合的，多用于编写测试代码。

### 延迟

在 Verilog 中，可在赋值语句中增加延迟，以模拟实际情况或产生需要的时序。延迟常用于编写测试代码，对实际电路来说是不可综合的，在综合过程中会忽略代码中的延迟。

```verilog
// 在顺序块中，本身占用时间
 #<时间> <变量> = <表达式>;
<变量> =  #<时间> <表达式>;

// 表达式变化，线网延迟变化
assign #<时间> <线网> = <表达式>;
// 指定延迟，任何驱动该线网的变化都延迟
<线网类型> #<时间> <标识符>;
```

### 赋值强度

赋值有强度

### 流程控制语句
1. if -else
2. case: case, casez, casex
3. 循环：
forever, repeat, while, do.. while, for, foreach

if 前可以用

- unique 要求条件互斥，即不能有任何情况使得多个条件表达式为真 或匹配多个条件项；要求分支完备，即不能有任何情况使得所有条件表达式为假或不匹配任何条件项（有 else 或 default 除外）。
- unique0 要求所有条件互斥，但不要求分支完备。
- priority 当条件重叠，即有情况使得多个条件表达式为真或匹配多个条件项时，靠前者优先。

```verilog
foreach(arr[i, j]) arr[i][j] = i + j;
repeat(8) ...;
forever ...;
```

### Always

```verilog
always_comb <语句/块>
```

- 启动时会执行一次，与真实组合逻辑电路的行为相符。
- 不允许被驱动的变量在任何其他过程中驱动。
- 如果内部条件分支不完整，会形成锁存器，编译器会给出警告。

### 阻塞和非阻塞

在顺序块中，阻塞赋值语句将“阻塞”后面语句的求值和赋值，即阻塞赋值语句是按书写次序逐条求值和赋值的；而非阻塞赋值语句不会“阻塞”后面语句的求值和赋值，所有非阻塞语句将与最后一条阻塞赋值语句同时执行。

## 接口

## 生成块

这与过程中的 for 语句形式相似，不过，循环条件所用的变量必须使用 genvar 关键字定义，循环步进和条件必须只由生成变量决定，例：

参数化格雷码转二进制

```verilog
module gray2bin #(
	parameter DW = 8
) (
	input wire [DW - 1 : 0] gray,
	output logic [DW - 1 : 0]bin
);
	generate
		for (genvar i = 0; i < DW; i++) begin : binbits
			assign bin[i] = ^gray[DW - 1 : i];
		end
	endgenerate
endmodule
```

## 任务和函数

任务和函数都只能在过程块中调用。

其中的 static 和 automatic 关键字用于指定任务和函数的生命周期，使用 automatic 关键字的任务和函数中的变量均为局部变量，在每次任务或函数调用时均会重新初始化，可被多个同时进行的过程调用，或被递归调用，类似于编程语言的可重入。FPGA 开发工具一般只支持 automatic 类型的任务和函数。

任务和函数本身类似于顺序块，因而在顺序块中能使用的语句 (过程赋值、流程控制等) 都能在任务和函数中使用。任务中可以有时序控制（延时、事件），而函数中不能有。

## 系统指令

有各种系统函数和任务可用。

编译指令：

- `default_nettype,设定默认线网类型
- `define、`undef 和 `undefineall,宏定义。
- `include,包含文件。
- `ifdef、`ifndef、`elsif、`else 和 `endif,条件编译。
- `timescale,时间单位和精度设置。
- `resetall,重置所有编译指令。
Verilog 有一个比较危险的特性是可以隐式定义线网, 即编译器将把未定义过的标识符认定为默认类型的线网，因而任何地方一个笔误，都将形成一个默认类型的线网，这多半是不可预期的，所以建议初学者将线网类型的默认值设置为 none。

```verilog
`timescale 1ns/100ps
```

左侧为时间单位，右侧为时间精度,时间精度必须不大于时间单位。定义了时间单位和精度之后，所有不带单位的时间均会乘以时间单位，所有时间均会被 四舍五入到时间精度。

# 其他语法
## wire/reg
**wire**

1. 连线型数据，线网类型；
2. 表示元件间的物理连线，不能保存数据；
3. 线网是被驱动的，可以用连续赋值语句或把元件的输出连接到线网等方式进行驱动；
4. 给线网提供驱动的赋值元件就是“驱动源”，线网的值由驱动源来决定；
5. 如果线网没有连接到驱动源，线网的缺省值为“Z”。

**reg:**

1. 寄存器型数据类型，通常用于对存储单元进行描述；
2. 这种变量可以保持它们自身的数值，直到该变量被指定了新的值为止；在过程被赋值的变量必须定义为 reg 型；
3. 只能存放无符号数；
4. 有符号数寄存器变量：integer。

## Case

case 语句通常综合成一级多路复用器

，而 if-then-else 则综合成优先编码的串接的多个多路复用器，如图的左边部分。通常，使用 case 语句要比 if 语句快，优先编码器的结构仅在信号的到达有先后时使用。条件赋值语句也能综合成多路复用器，而 case 语句仿真要比条件赋值语句快。

# FSM

三段式

```verilog
parameter S_1,S_2;
reg state,next_state;

always@(posedge clk) begin
   state<=next_state; 
end

//state trans
always@(*) begin
    case(state)
        S1:if(K1) next_state<=S2;
        S2:if(K2) next_state<=S1;
        default:;
    endcase
end

//state output
always@(posedge clk)begin
    if(state==S1) output1<=o1;
    else ;
end

always@(posedge clk)begin
    if(state==S2) output2<=o1;
    else ;
end
```

一段与三段结合

```verilog
parameter S_1,S_2;
reg state;

always@(posedge clk)begin
    case(state)
        S1:if(in1) state<=S2;
        S2:;
    endcase
end

always@(posedge clk)begin
    if(state==S1) output1<=o1;
    else ;
end 

always@(posedge clk)begin
    if(state==S2) output2<=o1;
    else ;
end
```

```verilog
// 一段，不推荐，单简单
reg[3 : 0]state;
always@(posedge clk or negedge rst_n)begin
    if(!rst_n)begin
        state <= IDLE;
        cmd <= ;
    end
    else begin
        case(state)
            IDLE:;
            default:;
        endcase
               
    end
end

// 两段，时序和组合分开，但容易出现毛刺
reg [3 : 0]c_state;
reg [3 : 0]n_state;

always@(posedge clk or negedge rst_n)begin
    if(!rst_n) c_state <= IDLE;
    else c_state <= n_state;
end

always@(*)beign
    case(c_state)
        
        default:;
    endcase
end

```

[Tan-YiFan/DigitalLogic-Autumn2020: 复旦大学 数字逻辑与部件设计实验 2020秋 (github.com)](https://github.com/Tan-YiFan/DigitalLogic-Autumn2020)

[数字验证_weixin_42454243的博客-CSDN博客](https://blog.csdn.net/weixin_42454243/category_11748195.html)

[张江打工人-CSDN博客](https://blog.csdn.net/weixin_43698385?type=blog)

**“IEEE Std 1364™-2005”以及之前的有关内容**

# Case 语句
## 综合出现锁存器

case 语句会综合出 latch，原因是 case 的**可能条件不全**，以下面的代码为例，默认 sel 为 2‘b11 的时候，y 的值保持，即综合过程中出现了 latch。

```verilog
always@(a or b or c or sel)
  case(sel)
    2'b00 : y = a;
    2'b01 : y = b;
    2'b10 : y = c;
  endcase
```

解决 1：

补全

```verilog
always@(a or b or c or sel)
  case(sel)
    2'b00 : y = a;
    2'b01 : y = b;
    2'b10 : y = c;、
    2’b11 : y = d;
  endcase
```

解决 2：

```verilog
always@(a or b or c or sel)
  case(sel)
    2'b00 : y = a;
    2'b01 : y = b;
    2'b10 : y = c;
    default: y = d;
  endcase
```

## 综合并行结构

我们通常情况下讨论的 case 语句都是并行结构，如

```verilog
always@(a or b or c or sel)
  case(sel)
    2'b00 : outc = a;
    2'b01 : outc = b;
    2'b10 : outc = c;
    2'b11 : outc = d;
  endcase
```

该代码会综合为 4 选 1 的 mux

## 综合出串行

通过**遍历条件**在 case 中是否**只会被执行一次**，我们可以判断 case 的综合结果为串行还是并行。

```verilog
always@(*)
	case(1'b1)
	request[3] : grant_reg = 4'b1000;
	request[2] : grant_reg = 4'b0100;
	request[1] : grant_reg = 4'b0010;
	request[0] : grant_reg = 4'b0001;
	default: grant_reg = 4'b0000;
```

这种串行结构有先后顺序，和 if 功能类似

## 不可综合的 case 语句

x 和 z 的 case 比较有可能会出现不可综合的情况，对于 casex 而言，前仿会把 x 值的输入当作不关心，而后仿会在条件检查时把 x 在门级模型中传播，冲突出现。

casez 也会出现相似的问题，虽说 casez 可以写出更加简洁的表达式，如优先级编码器和地址译码器等，但与 casex 相似的，casez 也会出现错误匹配的问题。

相关的语句 casez 和 casex 虽然在前仿中可以进行对应的比较，但有关 x 或 z 态的代码却是不可以综合的，在使用中需要多加注意。

## Verilog 中 if 语句和 case 语句综合成的电路

https://blog.csdn.net/vivid117/article/details/108825998

**尽量使用阶梯式的 assign 语句来编写**，代替 if-else，case 的编写。
虽然 if-else，case 有很多优势，如：
1. 有优先级顺序；
2. 件覆盖率容易 debug，这点对于验证来说，能够更快的 debug 出条件的覆盖率等
那么 if-else，case 在实际的电路设计中：
3. 很少利用其优先级的顺序，绝大多数是并行选择电路；
4. if-else 综合的电路并不利于后续时序和面积的优化，降低电路的性能
5. 并且 if-else 不能够传播不定态 X，这一点对于后续电路，验证中，导致不定态被掩盖，从而诱导出致命错误。

### 问题
- **Verilog 的 if-else 不能传播不定态 X**
对于一下代码片段，如果 a 的值为不定态，Verilog 语法会将其 a 的值与 `a==0` 等效，从而 out 会选择 in2，最终并没有将不定态传播出去。

```verilog
if(a)
	out = in1;
else
	out = in2;
```

改进的方法，推荐使用 assign 语句，如下所示:

```verilog
assign out = a ? in2: in1;
```

则此电路会将不定态传播出去，在仿真阶段就能够发现电路的错误。
虽然，随着 EDA 工具的发展，很多 eda 工具都能能够将**不传播不定态**的情形强行传播出来，例如 Synopsys VCS 提供 xprop 选项。但是一方面不是所有的 EDA 工具又可以支持。

2. **Verilog 的 case 也不能传播不定态 X，和上面的问题一样**。
3. **Verilog 的 if-else 语法会被综合成为优先级选择的电路，面积和时序得不到优化**

```verilog
if(sel1)
	out = in1[3:0];
else if (sel2)
	out = in2[3:0];
else if (sel3)
	out = in3[3:0];
else
	out = 4'b0;

```

### 对于优先级
**确实有优先级**，则更加推荐使用如下的设计形式：assign 可以将其等效：

```verilog
assign out = sel1 ? in1[3:0] :
		     sel2 ? in2[3:0] :
		     sel3 ? in3[3:0] :
		     4'b0;
```

**不需要优先级的逻辑设计**：

```verilog
assign  out = ( 4{sel1}) & in1[3:0] ) |
			  ( 4{sel2}) & in2[3:0] ) |
			  ( 4{sel3}) & in3[3:0] ) |
```

Verilog 的 case 优先级选额电路

Verolog 的 case 语法也会被综合成优先级选择电路，面积和时序均得不到优化，

虽然有的 EDA 工具可以提供注释，例如 Synopsys parallel case 和 full case 来时综合工具能够综合出并行选择逻辑，但是这样可以会造成前仿和后仿结果不一致的严重问题，从而产生重大的 BUG。电路的开发中，一般尽量少用这些指引注释，并推荐等效的 assign 语法编写电路

电路设计一般分为数据通路、控制模块。因此，在**数据通路**的设计中，可以**避免使用带有 reset 的寄存器**，这样的设计方法会减少面积，并且能够优化时序。

因此，在数据通路的设计上，可以使用不带 reset 的寄存器，而只在控制通路上使用带 reset 的寄存器

**CummingsSNUG1999Boston_FullParallelCase**

# 面向综合优化的 Verilog 代码风格

### 减少寄存器连线

一个寄存器设计很多逻辑时可能会导致负载太大。同一个信号在很多地方使用，布线也会变复杂，比如最常见的是参数信号，在很多模块都会有用到的情况，用寄存器复制的方法。

```verilog
always @(posedge clk or negedge rst_n)begin
    if(!rst_n)begin
        data_para0 <= 4'b0;
        data_para1 <= 4'b0;
        data_para2 <= 4'b0;
    end
    else begin
        data_para0 <= data_para;
        data_para1 <= data_para;
        data_para2 <= data_para;            
    end
end

```

### 先选后比再加

面积：加法器 > 比较器 > 选择器

乘法器本质上也是全加器。

所以就有先选后比，先选后加，先选后乘。

```verilog
assign sum[4:0] = enable ? (data_a + data_b) : (data_c + data_d);

//换一种实现方式：
assign add_a[3:0] = enable ? data_a : data_c;
assign add_b[3:0] = enable ? data_b : data_d;
assign sum[4:0]   = add_a + add_b;
```

### 数据通路与控制通路

数据通路打拍可以不带复位，**带着使能信号去打拍**，减少信号翻转，减少功耗。保证数据用的时候不是 X 态，

组合逻辑路径是否需要插入 pipeline，插入 pipeline 的位置需要注意。寄存器能少用就少用。

**尽量不要用除法**，首先除法器面积更大，除法也会有余数，余数是否需要保留就很麻烦。除以常数可以做成乘以定点常数的方法。

**乘以常数用移位加，也可直接用\* 号**。例如 a * 2‘d3，工具会帮你优化成 a << 2’d1 + a。甚至可能优化得更好。（杠：不要过度依赖工具）。关于用移位加还是\* 号的问题，博主做过综合后的面积对比，相对来说，工具还是优化那么一点点。直接用 * 号吧。

**尽量不要用减法**，减法要考虑到减翻的问题，尽量用加法。

# FPGA 实战高级篇

## 1 PCB

1.1 FPGA 高速电路

1.1.1 PCB 材料

相对介电常数，两块金属板之间以绝缘材料为介质时电容与真空介质电容比。影响传输线的阻抗，常数小信号传输速度快。损耗因数大影响高频信号，增大高频衰减。常用 FR-4，其 e 4.1-4.5

$$
\epsilon_r =
$$

1.1.2 传输线走线

传输线有 R、L、C，有微带和带状线两种。前者只有一个电压参考，后者有两个参考平面。

1.1.3 阻抗

单端走线控制阻抗 50 欧，差分阻抗 100 欧。

1.1.4 降低串扰和维持信号完整

双带线布局。走线垂直布设，增大信号层距离，减小信号与参考距离。

1.2 电源

电源单调性，提供软启动（MOS）

最大最小爬升电压

1.3 退耦电容

电源波动时提供少量瞬态能量

实际的电容也是 RLC 电路

## 2 时钟域

门控时钟、衍生时钟、事件驱动触发器均为时钟域类型

2.1 PLL 时钟域

```tcl
create_clock -period 10.000 -name clkin -waveform {0.5} [get_ports{clkin}]
// derive_pll_clocks

set_false_path -from [get_clocks {inst|altpll_componet|pll|clk[2]}] -to\[get_clocks{inst|altpll_componet|pll|clk[0]}]
// PLL产生多个时钟，若时钟域之间无数据交换，需要设置假路径，若存在，则设置多周期路径约束
```

2.2 单 bit 信号跨时钟域

处理亚稳态：寄存器有建立时间和保持时间，

两级寄存器，寄存器打两拍采样异步信号。两个寄存器必须使用同一时钟，发送和接收不得有其他组合逻辑；除了最后一个只能有一个扇出。

MTBF 平均故障时间

有时候使用三级触发器

同步快时钟域到慢时钟域：

- 开环，脉冲展宽 1.5 倍慢时钟
- 闭环，发送时钟将信号作为使能同步，接收时钟域接收使能反馈，作为正确接收的握手。好处是安全，缺点是延时。

2.3 多 Bit 信号

同步多个信号时可能出现 skew，常用策略有

- 多比特融合成单比特
- 多周期路径规划策略，使用同步加载信号安全得传输
- 格雷码

## 4 复位电路

大多数 ASIC 设计都是基于大量 flip-flop 或寄存器同步系统，所以复位信号 reset 来完成

同步复位，启动时同步于时钟；异步复位与时钟无关；同步化异步复位，异步复位同步释放。

建议使用异步复位

1. 有效利用器件资源，FPGA 内部寄存器现存复位置位端口，同步增加面积与时序分析
2. 复位异步更健壮

## 6 速度优化
 **速度面积互换、并行、同步设计原则。**

1. 速度的概念
吞吐量、设计延时、设计时序

吞吐量，除了同步，FPGA 的并行应该被采用，高速串行 IO 提高稳定

逻辑延时，输入与被处理后的时间间隔。例如，插入寄存器增加设计流水提升设计时序。一般实时要求需要延时优化

1. 时序收敛
2. 编写时考虑时序

$$
F_max = \frac{1}{T_{clk-q}+T_{logic}+T_{routing}+T_{setup}-T_{skew}}\\
时钟频率，时钟到达寄存器后数据到达Q时间\\触发器逻辑传播延时\\布线延时，下一个时钟到来时建立时间，传播延时
$$

- 通过减少关键路径的组合逻辑单元数。关键路径重组
- 适当逻辑复制：当某个信号扇出较大时造成信号到各个逻辑节点边长
- 插入寄存器
- 寄存器平衡，也即重定时

```verilog
assign a = b * c * d * e;
assign a = (b * c) * (d * e);
```

把三级乘法器平衡为两级

- 消除代码中的优先级

## 7 面积优化

1. 操作符平衡
2. 去除流水
3. 资源共享
在互斥的逻辑中，操作符可以共享。
有相同的表达式，也可以共享。
4. 复位。若不需要复位的不用复位，谨慎用复位，需要最好用异步
5. 器件，使用原语
