---
dateCreated: 2025-02-25
dateModified: 2025-04-11
---
# Ch8 发射
## 8.1 概述

**发射（issue）** 就是将符合一定条件的指令从**发射队列（Issue Queue, IQ）** 中选出来，送到 FU 的过程。对于一个 4-way 的超标量处理器来说，在寄存器重命名阶段可以同时处理四条指令，重命名后的指令被写到 ROB 的同时也被写到发射序列，这时到达了发射阶段。发射队列也可叫做**保留站（Reservation Station, RS）**。对于 in-order 处理器，指令按原有顺序写入，此时 IQ 相当于 FIFO；对于 OoO，只有少数指令按照这种方式执行，大多都是乱序的。

指令到了 IQ，不会按照程序中的顺序，只要操作数准备好了且满足发射条件就可以送到相应 FU 中去执行。因此发射队列的作用就是使用硬件保存一定数量的指令，然后从这些指令中找出可以执行的指令。IQ 的好坏决定了处理器可以获得的并行度，硬件设计比较复杂，而且它的时序一般都在关键路径上，影响处理器的周期时间。

发射阶段是处理器从顺序指令到乱序执行的分界线，由一些列硬件组成，除了 IQ 用来存储所有等到调度的指令，还有：

![](assets/ch8%20发射/发射阶段.png)

1. **IQ**，用来存储已经被寄存器重命名但是还没有被送到 FU 执行的指令，通常也被称为 RS。
2. **分配（Allocation）电路**，用来从 IQ 中找到空限定三名，将寄存器重命名后的指令存储到其中，不同的 IQ 的设计方法会直接影响到这部分电路的实现。
3. **选择（Select）电路，也称仲裁（Arbiter）电路**，如果 IQ 中存在多条指令的操作数都已经准备好，这个电路会按照一定的规则，从其中找到最合适的指令送到 FU 中执行。
4. **唤醒（Wake-up）电路**，当一条指令经过 FU 执行而得到结果数据时，会将其通知给 IQ 中所有等待这个数据的指令，这些指令中对应的源寄存器就会被设置为有效的状态，这个过程即为唤醒。如果 IQ 中的一条指令的源操作数都有效了，这个指令就处于准备好（ready）的状态，可以向选择电路发出申请。
发射阶段的实现有很多方式，这个阶段的中心部件就是 IQ。IQ 可以设计成集中式（Centralized），也可以是（Distributed）；可以是压缩的（Compressing），非压缩的（Non-Compressing）；可以是数据捕捉（Data-capture），也可以非数据捕捉（Non-data-capture）。上面的属性彼此正交，可以相互结合。

### 8.1.1 集中式 Vs 分布式

处理器中不同的 FU 共用一个发射队列，称为**集中式发射队列 Centralized IQ**；每个 FU 有一个单独的发射队列，称为**分布式发射队列 Distributed IQ**。

- CIQ 要存储所有 FU 的指令，容量需要很大，它利用效率高，不浪费发射队列中的每个空间，但是会使选择电路和唤醒电路变得复杂，因为要从数量庞大的指令中选择几条可以执行的指令（个数取决于每周期最多可以同时执行的指令个数，这个数值成为 Issue Width），这些被选中的指令还需要将 IQ 中的所尊相关指令都进行唤醒，这增加了面积和延时。
- DIQ 每个 IQ 的容量可以很小，简化了选择电路的设计（每个 IQ 都对应一个选择电路）。但是当一个 IQ 已经满了的时候，即使其他 IQ 还有空间，也不能继续向其中写入新的指令，此时需要将发射阶段之前的所有流水线都暂停，知道这个发射队列中有空闲的空间位置。如一段时间内执行了大量加减法指令，可能加减法的 FU 对应的 IQ 已满，阻碍寄存器重命名，后续所有指令都无法接受继续通过重命名，即使其他 FU 的 IQ 还有空间，也需要将发射阶段之前的流水线都暂停，导致 IQ 利用率低下。而且由于它的分布分散，唤醒操作需要的布线复杂度上升。
这两种方式各有优缺点，现代处理器结合两种，使得某几个 FU 共用一个发射队列。

### 8.1.2 数据捕捉 Vs 非数据捕捉

一般来说，在流水线哪个阶段读取寄存器对应这两种方法。

#### 数据捕捉

**在流水线的发射阶段之前读取寄存器，称为数据捕捉 Data-capture 的结构**。被寄存器重命名后的指令首先读取 PRF，然后将读取的数值随着指令写入发射队列中，如果有的寄存器的值还没有被计算出来，则会将寄存器编号写入 IQ，以供唤醒的过程使用，它会被标记为无法获得的状态，这些寄存器在之后通过旁路网络得到它们的值，不再需要访问物理寄存器。IQ 中，存储指令操作数的地方叫做 Payload RAM。

![](assets/ch8%20发射/payloadRAM.png)

可以看出，在 payload RAM 存储了指令源操作数的值，当指令从 IQ 中被仲裁电路选中时，就可以直接从 Payload RAM 中对应的地方将源操作数读取出来，并送到 FU 中去执行。当一条指令从 IQ 中被选中的同时，它会将目的寄存器的编号值进行广播，IQ 中其他指令都会将自身的源寄存器编号和这个广播的编号值进行比较，一旦发现相等的情况，则在 payload RAM 对应位置标记，当那条被选中的指令在 FU 中计算完毕时，就会将它的结果写到 payload RAM 这些对应位置中，这是通过 bypassing network 实现的，这个方式就像是 *payload RAM 在捕捉 FU 计算结果*，所以称为数据捕捉结构，IQ 负责比较寄存器的编号是否相等，而 payload RAM 负责存储源操作数，并捕捉对应 FU 结果。

**machine width 标记每周期实际可以解码和重命名的指令个数；issue width 标记每周期最多可以在 FU 中并行执行的指令个数**。在一般的 CISC 处理器中，处理器内部将一条 CISC 指令转化为几条 RISC 指令，而存储到 IQ 的是 RISC 指令，只有使 issue width 大于 machine width，才能使处理器的流水线平衡；而 RISC 处理器中，一般这两个值都是相等的，但是考虑到由于指令之间存在相关性等原因，即使每周期可以解码和重命名四条指令，很多时候，也不能每周期将四条指令送到 FU。因此只有使 issue width 大于 machine width，才能最大限度寻找在 FU 中可以并行执行的指令，所以现代高性能处理器会采用很多个 FU，使每周期可以并行执行的指令个数尽可能多。

这种方法在流水线的发射阶段之前就读取物理寄存器堆 PRF，所以 PRF 需要的读端口个数是 $machine\ width \times 2$（假设每条指令只有两个操作数），是直接和 machine width 相关的，过程如下：

![](assets/ch8%20发射/数据捕捉.png)

#### 非数据捕捉

**在发射阶段之后读取 PRF，称为非数据捕捉 Non-data-capture 结构**。被重命名的指令不会去读取 PRF，而是直接将源寄存器的编号放到 IQ 中，当指令从 IQ 被选中时，会使用这个源寄存器的编号来读取 PRF，将读取的值送到 FU 中执行。由于 IQ 中不需要存储源操作数的 payload RAM，处理速度增加。由于指令在发射后才读取 PRF，所以寄存器堆需要的读端口数是 $issue\ width \times 2$，这个值一般比较大，对读端口个数要求多一些。

![](assets/ch8%20发射/非数据捕捉.png)

数据捕捉方式所需要的 PRF 读端口少，但是由于需要在 IQ 中存储操作数，占用面积更大，而且这种方法中，很多源操作数需要经历两次读和一次写的过程，即从寄存器中读取，写到 IQ，然后从 IQ 中读取送到 FU，这会消耗更多能量。非数据捕捉的面积功耗更低。这两种方法都有使用。它们决定了寄存器重命名的实现方式，使用 ROB 重命名时需要配合数据捕捉的发射方式，因为这种方式中，指令在离开流水线时，需要将它的结果从 ROB 搬移到 ARF，采用数据捕捉可以不用关心这种指令结果的位置变化。

### 8.1.3 压缩 Vs 非压缩
### 8.2 发射过程的流水

## 8.3 分配

## 8.4 仲裁

## 8.5 唤醒
