---
dateCreated: 2025-02-24
dateModified: 2025-04-19
---
# Ch 3 虚拟存储器
## 3.1 概述

**虚拟存储器（Virtual Memory）** 但基本思想是，对于一个程序来说，它的 code/data/stack 的总大小可以超过实际物理内存的大小。操作系统把当前使用的部分放到物理内存中，而把其他未使用的部分放到更下一级存储器，如 disk/flah 中。比如一个大小为 32 MB 的程序运行在物理内存只有 16 MB 的机器上，操作系统通过选择，决定各个时刻将程序中的一部分 16 MB（或更小）的内容放在物理内存中，而把其他内容放到硬盘中，并在需要的时候在物理内存和硬盘之间交换程序片段。

可以说，一个程序就是运行在虚拟存储器空间的，它的大小由处理器的位宽决定。如 32 位处理器地址范围是 $0\sim0xFFFFFFFF$ 即 4 GB 这个范围就是程序可以产生的地址范围，其中的某个地址就称为**虚拟地址**。和虚拟存储器对应的是**物理存储器**，它是现实中可以直接使用的存储器，其中的某个地址就称为**物理地址**。物理存储器的大小不能超过处理器的最大可寻址空间。

没有使用虚拟地址的系统，处理器输出的地址直接送到物理存储器。使用了虚拟地址，处理器输出虚拟地址，这个地址会经过**内存管理单元（Memory Manage Unit, MMU）** 进行地址转换。

![](assets/ch3%20虚拟存储器/使用虚拟存储器.png)

使用虚拟存储器不仅便于程序运行，还可以给程序编写带来好处。直接使用物理存储器，如果需要同时运行多个程序，每个程序需要分配一块地址空间，这限制了程序的编写，而且不能使处理器随意执行程序。这对于应用领域比较单一的嵌入式系统是没问题的。对于扩展性要求高的复杂系统，需要虚拟存储器，这时每个程序总认为它占有处理器的所有地址空间，因此程序可以任意使用处理器的地址资源。编写程序时不需要考虑地址的限制，每个程序认为处理器中只有自己在运行，这些程序放到处理器中运行的时候，由操作系统负责调度，将物理存储器动态地分配各个程序，将每个程序的虚拟地址转化为相应的物理地址。

使用虚拟存储器不仅可以降低物理存储器的容量需求，还可以带来另外的好处，如**保护和共享**。通过操作系统动态地将每个程序的虚拟地址转化为物理地址，还可以实现程序的保护，即使两个程序都使用了同一个虚拟地址，它们也会对应到不同的物理地址，保证每个程序的内容不会被其他程序随便改写。而且通过这样的方式还可以实现程序简单共享，如操作系统内核提供了打印函数，第一个程序在地址 A 使用了 printf 函数，第二个程序在地址 B 使用了 printf 函数，操作系统在地址转换赌场罪，会将地址 A 和 B 都转换为相同的物理地址，这个物理地址就是 printf 函数在物理存储器中的实际地址，这样实现了程序的共享。虽然两个程序都使用了 printf 函数，但与不会使得 printf 函数占用物理存储器的两个地方。

## 3.2 地址转换

虚拟存储器最通用的方式是基于**分页 page**。虚拟地址空间的划分以页为单位，典型的页的大小为 4 KB，相应的物理地址空间也进行相同大小的划分，物理地址空间称为 frame（由于历史原因），和页大小相等。当程序开始运行时，会将当前需要的部分内容从硬盘中搬移到物理内存，每次搬移的单位就是一个页的大小。由于只有在需要的时候才将一个页的内容放到物理内存中，这种方式称为 demand page，它使处理器可以运行比物理内存大的程序。对于一个虚拟地址 VA 来说，$VA[11:0]$ 用来表示页内的位置，称为 *page offset*，VA 剩余部分用来表示哪个页，也称为 *VPN Virtual Page Number*。相应的，对于一个物理地址 PA 来说，$PA[11:0]$ 用来表示 frame 内的位置，称为 *frame offset*，而 PA 剩余的部分用来表示哪个 frame，也成为 *PFN Physical Frame Number*。由于页和 frame 的大小是一样的，所以从 VA 到 PA 的转化实际上也就是从 VPN 到 PFN 的转化，offset 不变。

例如，假设处理器是 16 位，它的虚拟地址范围是 $0\sim0xFFFF$，共 64 KB，页的大小是 4 KB。因此 64 KB 的虚拟地址包含了 16 个页，即 16 个 VPN；而这个系统的物理内存只有 32 KB，包含 8 个 PFN。现在有一个程序，它的大小大于 32 KB，这个程序在执行的时候，不能一次性调入内存中，这个机器必须有一个可以存放这个程序的下级存储器，以保证程序在需要的时候可以被调用。如下图所示，一部分虚拟地址已经被映射到物理空间，如 VPN 0（地址范围 $0\sim4K$）被映射为 PFN 2（地址范围 $8\sim12K$），VPN 1（地址范围 $4\sim8K$）被映射为 PFN 0（地址范围 $0\sim4K$）等。（配图有误）

![](assets/ch3%20虚拟存储器/地址转换.png)

程序中使用的地址是虚拟地址，虚拟地址会被送到处理器中专门负责地址转换的部件，即 MMU，被转换为物理地址后，再去访问物理内存而得到真正的数据。下面以 load 指令为例，仅考虑取数据的过程，实际每条指令本身的地址也是虚拟地址。对虚拟地址到物理地址的转换，只对 VPN 操作，页内的偏移不进行转化。也即页是地址转换的最小单元，例如：

```c
Load R2, 5[R1]; // 假设 R1 为 0
Load R2, 0[R1]; // 假设 R1 为 20500
Load R1, 0[R1]; // 假设 R1 为 32780
```

第一条指令执行时，得到的取数据的虚拟地址是 $R1+5=5$，地址 5 被送到 MMU，对于 page 0（范围 $0\sim4096$），被映射到物理空间的 frame 2（范围 $8192\sim12287$），MMU 将地址转换为物理地址 8197，并在物理内存中取数据。

第二条指令，虚拟地址落在 Page 5（范围 $20480\sim24575$），和页起始地址有 20 个字节距离，映射到物理内存的 frame 3，物理地址为 $12288+0=12308$。

第三条指令，虚拟地址落在 Page 8，而 Page 8 没有一个有效映射，即此时 Page 8 的内容没有存在物理内存中，而是在硬盘中，MMU 发现这个页没有被映射后，产生一个 Page Fault 异常给处理器，这时候处理器转到 Page Fault 对应的物理异常处理程序中（操作系统），它从物理内存的八个 Frame 寻找一个很少被使用的，假设选中了 frame 1，对应映射 Page 2，首先解除这两者的映射关系，此时虚拟地址 page 2 的地址范围被标记为没有映射，然后把需要的内容即 Page 8，从硬盘搬移到物理内存 frame 1 的空间，并标记这个映射关系。如果这个被替换的 frame 1 是脏 dirty 状态的，还需要将他的内容搬移到硬盘中，这里脏的概念和 cache 的一样，表示这个 frame 被修改过，被修改的数据还没来得及更新到硬盘中。处理完上述内容，就可以从异常处理中返回，此时返回到产生这个异常的指令，重新执行。

### 3.2.1 单级页表

访问硬盘的时间是以 ms 为单位的，这使得发生 Page Fault 异常处理需要很长时间，降低了处理器性能。因此为了减少 Page Fault 发生的频率，需要优化页在物理内存中的摆放。

### 3.2.2 多级页表

### 3.3.3 Page Fault

### 3.3.4 小结

## 3.3 程序保护

## 3.4 加入 TLB 和 Cache
### 3.4.1 TLB

### 3.4.2 Cache

### 3.4.3 加入流水线
