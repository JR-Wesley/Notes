---
dateCreated: 2025-02-26
dateModified: 2025-05-19
---
# Ch 9 执行
## 9.1 概述

**执行（Execution）** 阶段负责指令执行，接收至指令的源操作数，功能单元（Function unit）对其进行规定操作，然后执行结果对**处理器状态（Architecture State）** 更新。一个处理器包括的 FU 的类型取决于这个处理器支持的指令集，一般 RISC 指令集包括以下操作类型：算术、访存、控制流、特殊指令。不同类型的指令有不同的复杂度，在 FU 中的执行时间也不同，称作 latency。现代处理器中为了获得更大并行度，一般会使用几个 FU 并行运算。不同 FU 有不同的延迟，FU 的个数决定了每个周期最大可以并行执行的指令个数，也就是前文所说的 issue width。FU 在运算完成后不会使用它的结果立马对处理器的状态进行更新，而是将结果写道临时的地方，比如不写到 ARF 而是 PRF，这些临时的状态称为**推测状态（Speculative State）**，等到一条指令顺利离开流水线即退休的时候，它才会真正地对处理器对状态更新。

![](assets/ch9%20执行/执行阶段的位置.png)

图中的执行阶段包括了所有类型的 FU，如 **FPU Floating-Point unit 浮点运算/ALU Arthmetic Logic Unit 算术和逻辑运算/AGU Address Generation Unit 计算访存地址**。当使用虚拟存储器时，AGU 计算的地址只是虚拟地址还需要转换为物理地址；**BRU Branch Unit 对控制程序流的指令计算目标地址**。当然实际还会有很多其他功能 FU。

执行阶段另一个重要部分就是**旁路网络（bypassing network）**，负责将 FU 的运算结果马上送到需要的地方，如 PRF/FU 输入端/Store Buffer。现代超标量处理器中，如果想要背靠背地执行相邻的相关指令，旁路网络是必须的，但是算着并行执行的指令个数增多，旁路网络变得越发复杂，会在处理器中制约速度提升的关键部分。

假设不考虑旁路网络，指令的操作数可以来自 PRF（对应非数据捕捉结构），也可以来自 payload RAM（对应看数据捕捉结构），每个 FU 和数据源的端口就是通过仲裁电路联系的。每个 FU 和一个 1-of-M 的仲裁电路一一对应。每个仲裁电路如果选择了一条指令，这条指令就会读取数据源，从而得到对应操作书，然后将这条指令送到对应 FU 中执行。每个仲裁电路、每个 FU 都和 PRF（payload RAM）一一对应。这样使设计得到简化。下图中 PRF 总共需要的读端口个数和 issue width 直接相关，如果追求更大的并行度，就需要更大的 issue width，PRF 也需要更多读端口（payload RAM 和 IQ 绑定，使用分布式 IQ 可以减少对 payload RAM 读端口的需求），又会制约处理器速度的提升。所以现代处理器为了解决矛盾，多采用 cluster 结构。

![](assets/ch9%20执行/FU和读端口的对应关系.png)

## 9.2 FU 的类型
### 9.2.1 ALU

这是一种最普通的 FU，所有的处理器都会有这个部件，它负责对整数类型的数据进行计算，得到整数类型的结果，它一般被称做 **ALU (Arithmeticand LogicUnit)**。整数的加减、逻辑、移位运算，甚至是简单的乘除法、数据传输指令，例如 MOV 指令和数据交换 (byte-swap) 类型的指令、分支指令的目标地址的计算、访问存储器的地址计算等运算，都会在这个 FU 中完成，具体的运算类型取决于处理器微架构 (microarchitecture) 的设计。

加减法是最普通的算术运算了，但是不同的指令集直接影响着加减法的硬件实现，例如在 MIPS 指令集中，如果加减法发生了溢出 (overflow)，那么就需要产生异常 (exception)，在异常处理程序中对这个溢出进行处理。而 ARM 指令集则直接定义了状态寄存器 (在 ARM 中称为 CPSR 寄存器)，当加减法指令发生溢出时，会在 CPSR 中将相应的位置 1，后续的指令可以直接使用 CPSR 寄存器，从而可以不用产生异常。在 CPSR 寄存器中还包括了运算结果的其他状态位，如表 9.1 表示。

<table>
  <caption>CPSR寄存器中的状态标志位</caption>
  <thead>
    <tr>
      <th>标志位</th>
      <th>全称</th>
      <th>条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>N</td>
      <td>Negative 标志位</td>
      <td>等于 result[31]，其中 result 表示运算的结果，通常用于有符号数的运算</td>
    </tr>
    <tr>
      <td>Z</td>
      <td>Zero 标志位</td>
      <td>如果运算结果为 0，则设为 1，否则为 0；通常用于比较两两个数是否相等</td>
    </tr>
    <tr>
      <td>C</td>
      <td>Carry 标志位</td>
      <td>通常用于无符号数的运算,其为 1 的条件是:
(1) 加法的结果大于等于 232
(2) 减法的结果大于等于 0
</td>
    </tr>
    <tr>
      <td>V</td>
      <td>Overflow 标志位</td>
      <td>通常用于有符号数的运算,其为 1 的条件是:
(1) 正 + 正=负
(2) 负 + 负=正
(3) 负一正=正
(4) 正一负=负
</td>
    </tr>
  </tbody>
</table>

### 9.2.2 AGU
### 9.2.3 AGU
### 9.2.4 其他 FU
## 9.3 旁路网络
### 9.3.1 简单设计旁路网络
### 9.3.2 复杂设计旁路网络
## 9.4 操作数的选择
## 9.5 Cluster
## 9.6 存储器指令加速
