---
dateCreated: 2025-08-15
dateModified: 2025-08-15
---
TP/PP Tensor Parallelismï¼šæŠŠçº¿æ€§å±‚æŒ‰ç…§ è¡Œæˆ–è€…åˆ—ç»´åº¦å¯¹æƒé‡è¿›è¡Œåˆ’åˆ†ï¼Œï¼ŒåŸ æœ¬çº¿æ€§å±‚æŒ‰åˆ—è¿›è¡Œåˆ’åˆ†ï¼Œæ¯ä¸ª GPU åªéœ€ è¦å­˜ä¸€éƒ¨åˆ†çš„æƒé‡å³å¯ï¼Œæœ€åé€šè¿‡ All-reduce æ“ä½œæ¥åŒæ­¥æœ€ç»ˆç»“æœã€‚Pipeline Parallelismï¼šæ˜¯æ¨¡å‹åšå±‚ é—´åˆ’åˆ†ï¼Œå¦‚æœæ¨¡å‹åŸæœ¬æœ‰ 36 å±‚ï¼Œæƒ³åœ¨ 4 ä¸ª GPU ä¹‹é—´è¿è¡Œ pipelineï¼Œé‚£ä¹ˆæ¯ä¸ª GPU åªè¦æŒ‰ç…§å…ˆåé¡ºåºå­˜ 9 å±‚æ¨¡å‹å³å¯

TP â€¢ é€šä¿¡é‡:ğ‘‡ = ğµ âˆ— ğ‘† âˆ— ğ» âˆ— 2 âˆ— ğ¿ğ‘ğ‘¦ğ‘’ğ‘Ÿğ‘  âˆ— 2 ğ‘¡ğ‘âˆ’1 ğ‘¡ğ‘ â€¢ å……åˆ†åˆ©ç”¨ GPU çš„ç®—åŠ›èµ„æº â€¢ å¯¹ GPU çš„å¸¦å®½ä¾èµ–æ¯”è¾ƒé«˜ï¼Œå•ä¸ª GEMM çš„ç»´åº¦å˜å° â€¢ å° batch çš„æ—¶å€™æ‰“ä¸æ»¡å¸¦å®½,å¤§ batch çš„æ—¶å€™å¸¦å®½ ç“¶é¢ˆ â€¢ æ€§èƒ½ä¸Šç•Œæ˜¯ 1/tp

PP 0 500 1000 1500 2000 2500 3000 3500 4000 1 2 4 8 16 32 64 128 PP Prefill Latency pp1 pp2 pp4 pp8 0 5 10 15 20 25 30 35 40 45 1 2 4 8 16 32 64 128 PP Decode Latency pp1 pp2 pp4 pp8 â€¢ é€šä¿¡é‡ï¼šğ‘‡ = ğµ âˆ— ğ‘† âˆ— ğ» âˆ— ğ¿ğ‘ğ‘¦ğ‘’ğ‘Ÿğ‘  ğ‘ƒğ‘ƒ â€¢ å¯¹ Memory å¸¦å®½ä¾èµ–ä½ï¼Œä½†æ˜¯å¯¹ GPU çš„åˆ©ç”¨ ç‡æ¯”è¾ƒä½ï¼Œéœ€è¦åˆ†ä¸º micro batch â€¢ ä¸éœ€è¦ç­‰å¾… backwardï¼Œbubble æ›´å®¹æ˜“æ§åˆ¶ â€¢ Batch è¾ƒå¤§çš„æ—¶å€™èƒ½å¤Ÿæ‹¿åˆ°è¾ƒå¥½çš„æ€§èƒ½ â€¢ æ€§èƒ½ä¸Šç•Œæ˜¯ï¼šæ¥è¿‘ bs1 çš„æ€§èƒ½

TP+PP

TP8 å° batch æ€§èƒ½æœ€å¥½ï¼Œbatch å¤§çš„æ—¶å€™ bound åˆ°å¸¦å®½ â€¢ PP8 æ€§èƒ½æœ€å·®ï¼Œä½†æ˜¯å¯¹å¸¦å®½ä¾èµ–å°ï¼Œåœ¨ è¶…å¤§ batch çš„æ—¶å€™å¯èƒ½è¶…è¿‡ TP8ï¼Œâ€¢ TP4+PP2ï¼šå¤§ batch æ—¶å€™ç”¨ PP å‡å°‘ TP8 å¯¹ å¸¦å®½çš„ä¾èµ–ï¼Œåˆ©ç”¨ PP ç‰¹æ€§é€¼è¿‘ TP4 çš„æ€§ èƒ½æ”¶ç›Š â€¢ å¯¹ç‰¹æ®Šæ‹“æ‰‘å¯èƒ½æœ‰æ•ˆ

**Table of Contents**

- RDMA Protocol Stack
- RDMA Connection Manager(CM)
- OpenMPI RDMA Usage
- NCCL RDMA Usage
- RDMA access GPU memory directly (aka. GPUDirect,GDR)
- Reference
- Appendix: RDMA Software Stack
- Appendix: RDMA Feature List
- Appendix: RDMA Call Flow
- Appendix: RDMA NIC List
- Appendix: RDMA NIC Driver (Mellanox)
- Appendix: Infiniband Network Topology

**RDMA Protocol Stack**

- IB Stack Layer
- ULP
- Transport
- Network
- Link
- Physical
- IB Packet Structure

![]([https://conf01.birentech.com/download/attachments/6818177/image2020-12-7_10-16-27.png?version=1&modificationDate=1607260588000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2020-12-7_10-16-27.png?version=1&modificationDate=1607260588000&api=v2))

**RDMA Connection Manager(CM)**

- Connection Type
- Connected â€“1 Local QP: 1 Remote QP
- Reliable â€“RC
- Eg. FTP,NCCL
- Unreliable â€“UC
- Eg. Video
- Datagram â€“1 Local QP: N Remote QP (scalable)
- Reliable â€“RD
- Eg.??
- Unreliable â€“UD
- Eg. Audio
- Illustrate
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-2-25_17-12-40.png?version=1&modificationDate=1614197561000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-2-25_17-12-40.png?version=1&modificationDate=1614197561000&api=v2))
- ![]([https://conf01.birentech.com/download/thumbnails/6818177/image2021-2-25_17-14-2.png?version=1&modificationDate=1614197642000&api=v2](https://conf01.birentech.com/download/thumbnails/6818177/image2021-2-25_17-14-2.png?version=1&modificationDate=1614197642000&api=v2))
- Connection Handshake

![]([https://conf01.birentech.com/download/thumbnails/6818177/image2020-12-7_10-31-0.png?version=1&modificationDate=1607261461000&api=v2](https://conf01.birentech.com/download/thumbnails/6818177/image2020-12-7_10-31-0.png?version=1&modificationDate=1607261461000&api=v2))

- Connection Call Flow
- UCX RDMA UCT: Passive server port listen for client connect
- UMD librdmacm: Accept client connection based on network event and internal state machine
- KMD kCM: User connection manager access layer,responsible for parse IB driver API command
- KMD kMAD: Management datagram layer,responsible for encapsulate handshake REP packet
- KMD kVERB: Verbs layer, responsible for programming HCA to send MAD packet
- KMD IB NIC: Mellanox driver layer, responsible for actually send IB packet onto wire
- Illustrate

![]([https://conf01.birentech.com/download/attachments/6818177/image2021-3-16_14-19-44.png?version=1&modificationDate=1615832385000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-3-16_14-19-44.png?version=1&modificationDate=1615832385000&api=v2))

**OpenMPI RDMA Usage**

- OpenMPI RMA(Remote Memory Access) operation is mapped to RDMA operation
- OpenMPI use UCX as PML backend
- UCX use Infiniband as UCT
- Infiniband UCT will initiate RDMA operation through two modes
- Normal mode â€“Invoke libibverbs
- Accelerate mode â€“Invoke NIC UMD
- RMA PUT msg will split into multiple RDMA WRITE packets

![]([https://conf01.birentech.com/download/attachments/6818177/image2020-12-7_10-20-19.png?version=1&modificationDate=1607260820000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2020-12-7_10-20-19.png?version=1&modificationDate=1607260820000&api=v2))

- RDMA packet content
- Transport Layer Header
- BTH: Basic Transport Header
- ETH: Extended Transport Header
- RETH: RDMA ETH
- Virtual Address: 64b. Correspond to Mellanox RADDR seg rdma_raddr
- Remote Key: 32b. Correspond to Mellanox RADDR seg rdma_rkey
- RDMA Transaction
- There are two RDMA transaction in UCX
- Eager Protocol
- Use pre registered buffer to do RDMA transfer
- For small/medium size message, low latency
- Rendezvous Protocol (RNDZ)
- Use dynamic registered buffer to do RDMA transfer
- For large size message, high bandwidth
- Eager Protocol
- Use RDMA WRITE to transfer data from sender to receiver
- Illustrate
- ![]([https://conf01.birentech.com/download/thumbnails/6818177/image2021-3-31_16-54-56.png?version=1&modificationDate=1617137697000&api=v2](https://conf01.birentech.com/download/thumbnails/6818177/image2021-3-31_16-54-56.png?version=1&modificationDate=1617137697000&api=v2))
- There are two data transfer type based on message size
- Short Copy (Short)
- For small size message
- Sender innline data directly into RDMA WRITE command header
- Buffered Copy (Bcopy)
- For medium size message
- Sender copy data from user buffer to pre registered RDMA buffer
- Sender RDMA WRITE RDMA buffer to receiver's pre registered RDMA buffer
- Receiver copy RDMA buffer to user buffer
- RNDZ Protocol
- There are two RNDZ protocol in UCX (Zero copy: Zcopy)
- PUT Protocol (PUT Zcopy)
- GET Protocol (GET Zcopy)
- PUT Protocol
- Use RDMA WRITE to transfer data from sender to receiver
- Sender send RNDZ_START to start transfer
- RNDZ_START â€“In UCX code: RTS(Ready To Send)
- Receiver register MR after receive RNDZ_START
- Receiver send RNDZ_REPLY to acknowledge transfer
- RNDZ_REPLY â€“In UCX code: RTR(Ready To Receive)
- Sender issue RDMA WRITE to receiver's MR after receive RNDZ_REPLY
- Sender send FIN to receiver after RDMA WRITE
- FIN â€“In UCX code: ATP(??)
- 7Receiver deregister MR after receive FIN
- Illustrate
- ![]([https://conf01.birentech.com/download/thumbnails/6818177/image2021-3-31_16-39-16.png?version=1&modificationDate=1617136756000&api=v2](https://conf01.birentech.com/download/thumbnails/6818177/image2021-3-31_16-39-16.png?version=1&modificationDate=1617136756000&api=v2))
- GET Protocol
- Use RDMA READ to transfer data from sender to receiver
- Sender register MR
- Sender send RNDZ_START to start transfer
- Receiver issue RDMA READ from sender's MR after receive RNDZ_START
- Receiver send FIN to sender after RDMA READ
- FIN â€“In UCX code: ATS(??)
- Sender deregister MR after receiver FIN
- Illustrate
- ![]([https://conf01.birentech.com/download/thumbnails/6818177/image2021-3-31_16-39-42.png?version=1&modificationDate=1617136782000&api=v2](https://conf01.birentech.com/download/thumbnails/6818177/image2021-3-31_16-39-42.png?version=1&modificationDate=1617136782000&api=v2))
- RDMA GET Protocol latency is lower than RDMA PUT Protocol
- UCX default use GET protocol
- TBD: when switch to PUT protocol
- Pipeline PUT/GET Protocol
- Sometimes GPU data should be copied to host memory before RDMA transfer
- Not support GDR
- Non-contiguous GPU data pack/unpack for RDMA transfer
- Under such condition UCX will pipeline PUT/GET protocol to increase throughput
- Split data into fragments
- Transfer per fragment use PUT/GET protocol
- At sender side, overlap Next frag's D2H copy with Current frag's RDMA PUT
- At receiver side, overlap Next frag's RDMA GET with Current frag's H2D copy

**NCCL RDMA Usage**

- Background info
- NCCL kernel refer to: [NCCL Device Kernel]([https://conf01.birentech.com/display/SOF/NCCL+Device+Kernel](https://conf01.birentech.com/display/SOF/NCCL+Device+Kernel))
- We'll compare NCCL inter node communication modes below
- Normal mode
- RDMA mode
- Normal Mode
- For each channel/peer/direction, allocate multiple sockets
- For each socket, allocate a data thread to handle data transfer on that socket
- For each data block, split block into multiple chunks by number of sockets, assign chunk to each socket
- Thus multiple CPU threads parallelly transfer different data chunks on different sockets
- Which consumes CPU!! (as compared to RDMA mode described in next chapter)
- Illustrate
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-2-4_14-11-3.png?version=1&modificationDate=1612372263000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-2-4_14-11-3.png?version=1&modificationDate=1612372263000&api=v2))
- RDMA Mode
- For each channel/peer/direction, allocate one NIC QP (Queue Pair)
- For each data block, RDMA write the whole block to remote MR (Memory Region)
- Data transfer is handled by NIC HW
- No CPU consumption!! (RDMA advantage)
- NIC HW will chunk data block into multiple RDMA WRITE packets on the wire
- As "Remote Memory Access" chapter describes
- Illustrate
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-2-4_14-18-15.png?version=1&modificationDate=1612372695000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-2-4_14-18-15.png?version=1&modificationDate=1612372695000&api=v2))
- RDMA Transaction

- [1] Sender register its meta mem to NIC as MR(Memory Region)

- Mm â€“Memory region of send meta
- Amâ€“Address of send meta
- Kmâ€“Remote key of send meta

- [2] Receiver register its data mem to NIC as MR

- Md â€“Memory region of recv data
- Ad â€“Address of recv data
- Kd â€“Remote key of recv data

- [3] Sender announce its meta MR(Am,Km) on bootstrap ring

- Bootstrap ring is pre-built when NCCL initialized

- [4] Receiver RDMA write to send meta MR(Am,Km) with recv data MR slot info (Ad,Kd)
- [5] Sender RDMA write to recv data MR slot(Ad,Kd) with data block

- Illustrate
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-2-9_17-3-20.png?version=1&modificationDate=1612814601000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-2-9_17-3-20.png?version=1&modificationDate=1612814601000&api=v2))
- RDMA Sequence Diagram
- RDMA Top Level Sequence
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-4-20_10-40-14.png?version=1&modificationDate=1618843214000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-4-20_10-40-14.png?version=1&modificationDate=1618843214000&api=v2))
- RDMA Initialization
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-4-13_14-40-31.png?version=1&modificationDate=1618252831000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-4-13_14-40-31.png?version=1&modificationDate=1618252831000&api=v2))
- RDMA Connection
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-4-13_14-4-44.png?version=1&modificationDate=1618250684000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-4-13_14-4-44.png?version=1&modificationDate=1618250684000&api=v2))
- RDMA I/O
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-4-13_13-58-48.png?version=1&modificationDate=1618250329000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-4-13_13-58-48.png?version=1&modificationDate=1618250329000&api=v2))

**RDMA access GPU memory directly (aka. GPUDirect,GDR)**

- NIC can directly access GPU memory
- Instead of use host memory to avoid extra GPU to host memory copy
- NCCL will enable GDR when
- Detect system supports PeerDirect driver
- PeerDirect Core â€“ [[https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed](https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed)]([https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed](https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed))
- Nvidia GPU PeerDirectâ€“ [[https://github.com/Mellanox/nv_peer_memory](https://github.com/Mellanox/nv_peer_memory)]([https://github.com/Mellanox/nv_peer_memory](https://github.com/Mellanox/nv_peer_memory))
- AMD GPU PeerDirectâ€“ [[https://github.com/RadeonOpenCompute/ROCK-Kernel-Driver](https://github.com/RadeonOpenCompute/ROCK-Kernel-Driver)]([https://github.com/RadeonOpenCompute/ROCK-Kernel-Driver](https://github.com/RadeonOpenCompute/ROCK-Kernel-Driver))
- Register GPU mem to NIC as MR
- PeerDirect Driver Architecture
- PeerDirect GPU Driver: Client driver (Eg. Nvidia GPU / AMD GPUâ€¦) which provide device DMA page management hooks
- PeerDirect GPU Driver is vendor specific
- PeerDirect Core Driver: Bridge driver which connect producer(GPU/Storageâ€¦) with consumer(NIC)
- PeerDirect Core Driver is common for all vendor GPUs
- Detailed GDR flow work as below
- Top Level Flow
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-41-31.png?version=1&modificationDate=1638265292000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-41-31.png?version=1&modificationDate=1638265292000&api=v2))
- Initialization Flow
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-44-30.png?version=1&modificationDate=1638265471000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-44-30.png?version=1&modificationDate=1638265471000&api=v2))
- Memory Region Registration Flow
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-46-3.png?version=1&modificationDate=1638265563000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-46-3.png?version=1&modificationDate=1638265563000&api=v2))
- Sync I/O Flow
- ![]([https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-47-12.png?version=1&modificationDate=1638265632000&api=v2](https://conf01.birentech.com/download/attachments/6818177/image2021-11-30_17-47-12.png?version=1&modificationDate=1638265632000&api=v2))

**Reference**

- IB Specification Vol 1-Release-1.4
- OpenUCX
- librdmacm
- Linux Kernel
- [NCCL Device Kernel]([https://conf01.birentech.com/display/SOF/NCCL+Device+Kernel](https://conf01.birentech.com/display/SOF/NCCL+Device+Kernel))
- Mellanox RDMA Aware Programming User Manual

**Appendix: RDMA Software Stack**

- RDMA Software Stack
- Mellanox OFED
- [[https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed](https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed)]([https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed](https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed))
- Latest version is 5.2-2.2.0.0 (2021/03) 5.2-

**1. BR104 FP32 æ ¼å¼ä¸‹ï¼ŒGEMM ç®—åŠ› (MACs/cycle) æœ‰å¤šå°‘ï¼Ÿï¼šB**

A. 16384

B. 8192

C. 32768

**è§£æï¼šFP32 æ ¼å¼ (TF32) ä¸‹,gemm ç®—åŠ›ä¸º 8192**

**2. å¯¹äº conv fwd stride1 k3x3ï¼Œå‡å¦‚ activation=(2, 128, 16, 16), ä¸”ä¿è¯ activation æ—  reloadï¼Œåœ¨ NUMA/FP32 ä¸‹ä» L2 load è‡³ B buffer éœ€è¦ï¼ˆï¼‰cyclesï¼šD**

A. 2*16*16*128*4/44 = 5958

B. 2*24*16*128*4/44 = 8937

C. 2*16*16*128*4/256 = 1024

D. 2*24*16*128*4/256 = 1536

**è§£æï¼šç”±äº k3x3ï¼Œpadding_factor=1.5, å› æ­¤éœ€è¦å¤š load 50% æ•°æ®**

**3. å¯¹äº conv ç±»ç®—å­ï¼Œå‡å¦‚ A/B buffer æ•°æ®éƒ½ä» L2/HBM load, æ­¤æ—¶ç®—å­ç†è®ºæ€§èƒ½ç”¨ä»¥ä¸‹å“ªä¸ªå…¬å¼è®¡ç®—ï¼Ÿ: A**

Aï¼šmax(ldA + ldB, GEMM, GEMM_wr)

Bï¼šmax(ldA, ldB, GEMM, GEMM_wr)

C: max(ldA+ldB+GEMM_wr, GEMM)

**è§£æï¼š**

**4. vcore ç†è®ºæ€§èƒ½å–å˜é‡è€—æ—¶çš„ï¼ˆï¼‰ï¼Ÿï¼šA**

Aï¼šæœ€å¤§å€¼

Bï¼šæœ€å°å€¼

C: å¹³å‡å€¼

**è§£æï¼š**

**5. BR104 æ¯ä¸€ä¸ª eu æœ‰ï¼ˆï¼‰æ¡ laneï¼Ÿï¼šC**

Aï¼š4

Bï¼š8

C: 16

D: 32

**è§£æï¼š**

**6. Vcore ç†è®ºæ€§èƒ½è®¡ç®—éœ€è¦è€ƒè™‘å“ªäº›å˜é‡ï¼Ÿï¼šABC**

Aï¼šè®¡ç®—é‡è€—æ—¶

Bï¼šæŒ‡ä»¤è€—æ—¶

C: è®¿å­˜è€—æ—¶

**è§£æï¼š**

**1. è®¡ç®—å¼ºåº¦ operational intensity (Imax) çš„è®¡ç®—æ–¹å¼ï¼šC**

A. Imax = Maximum FLOPs Per Second

B. Imax = Maximum Memory Access Per Second

C. Imax = Maximum FLOPs Per Second/Maximum Memory Access Per Second

D. Imax = Maximum Memory Access Per Second/Maximum FLOPs Per Second

**2. å…³äº Ridge point æè¿°æ­£ç¡®çš„æ˜¯ï¼šAC**

A. ç›¸åŒçš„ HW ç®—åŠ›ä¸‹ï¼ŒRidge point çš„ X åæ ‡å¯¹åº”çš„è®¡ç®—å¼ºåº¦è¶Šå¤§ï¼Œè¡¨æ˜ä¼˜åŒ–éš¾åº¦è¶Šå¤§ï¼›

B. ç›¸åŒçš„ HW ç®—åŠ›ä¸‹ï¼ŒRidge point çš„ X åæ ‡å¯¹åº”çš„è®¡ç®—å¼ºåº¦è¶Šå¤§ï¼Œè¡¨æ˜ä¼˜åŒ–éš¾åº¦è¶Šå°ï¼›

C. Ridge point çš„ X åæ ‡åæ˜ äº†èƒ½è¾¾åˆ°çš„ peak performance æ‰€éœ€è¦çš„æœ€å°è®¡ç®—å¼ºåº¦ï¼›

D. åªæœ‰åœ¨ Ridge point ä¸Šï¼Œæ‰ä»£è¡¨æœ€å¥½çš„æ€§èƒ½ï¼›

**è§£æï¼šRidge point ç¿»è¯‘ä¸ºè„Šç‚¹ã€‚**

**3. BR ç¡¬ä»¶æ¶ˆé™¤ compute bound çš„æ–¹å¼æœ‰ï¼šABD**

Aï¼šå……åˆ†å¹¶è¡Œ, åˆ©ç”¨æ‰€æœ‰è®¡ç®—å•å…ƒ

Bï¼šæŒ‡ä»¤å±•å¼€ï¼ŒæŒ‡ä»¤è°ƒåº¦ï¼Œhide SFU latency

C: å¢åŠ  kernel çš„ workload

D: åˆ©ç”¨ fmad ä»£æ›¿ fmul + fadd

**è§£æï¼š**

**4. BR ç¡¬ä»¶æ¶ˆé™¤ Memory bound çš„æ–¹å¼æœ‰ï¼šABD**

Aï¼šldmma æŒ‡ä»¤è®¿é—® matrix ä¼˜å…ˆä½¿ç”¨ col-major

Bï¼šä¼˜å…ˆè®¿é—® local memory

C: issue æ›´å¤šçš„ ld æŒ‡ä»¤

D: æ•°æ®é¢„å–

**è§£æï¼š**

**5. ç®—å­èåˆçš„ä¼˜ç‚¹æœ‰ï¼šACDE**

Aï¼šé™ä½äº† HBM/Cache è®¿å­˜é‡ï¼›

Bï¼šé™ä½äº† Kernel çš„è®¡ç®—é‡ï¼›

C: é™ä½äº†æ˜¾å­˜å ç”¨ï¼›

D: ä¼˜åŒ–äº†è®¡ç®—æµæ°´ï¼Œæé«˜äº†å¹¶è¡Œåº¦ï¼›

E: å‡å°‘äº† Kernel launch çš„å¼€é”€ï¼›

**è§£æï¼š**

[]([https://conf01.birentech.com/pages/viewpage.action?pageId=100407966](https://conf01.birentech.com/pages/viewpage.action?pageId=100407966))

**1ã€****åæ±‡ç¼–æ–‡ä»¶ä¸­çš„æŒ‡ä»¤åœ°å€ï¼Œä¸ trace ä¸­çš„ PC å€¼çš„å¯¹åº”å…³ç³»æ˜¯ï¼šï¼ˆAï¼‰**

A. HEX(PC_value) = HEX(dis_addr) // 8

B. HEX(PC_value) = HEX(dis_addr)

C. HEX(PC_value) = HEX(dis_addr) // 16

D. HEX(PC_value) = HEX(dis_addr) // 32

**è§£æï¼š**

**2ã€inst trace tlr é‡Œé¢çš„æ•°æ®ä¸º 03db5004f3ï¼Œfp32 å¯¹åº”çš„æ•°æ®ä¸ºï¼šï¼ˆBï¼‰**

A. 3db5004f = 0.0883794948459

B. 3db504f3 = 0.0883883461356

C. 04f33db5 = 5.71856944083e-36

D. b53df304 = -7.07616209183e-07

**è§£æï¼š**

**3ã€simt one or two-source inst / simt three-source instï¼Œä¸” src éƒ½ä¸º tlrï¼Œå…¶ issue cycle æ•°åˆ†åˆ«ä¸ºï¼šï¼ˆBï¼‰**

A. 1/2

B. 2/4

C. 1/3

D. 2/3

**è§£æï¼š**

**4.æŒ‡ä»¤å‘¨æœŸæœ‰å“ªå‡ ä¸ªï¼šï¼ˆACDEFï¼‰**

A. å–å€

B. ç¼–ç 

C. è¯‘ç 

D. æ‰§è¡Œ

E. è®¿å­˜

F. å†™å›

**è§£æï¼š**

**5. æœ‰å¤šå°‘ç§æŒ‡ä»¤å†’é™©å†²çªï¼šï¼ˆABCï¼‰**

A. Structure Hazardâ€“ è®¡ç®—èµ„æºå†²çª

B. Data Hazardâ€“ æ•°æ®ä¾èµ–å†²çª

C. Control Hazardâ€“ åˆ†æ”¯æ§åˆ¶å†²çª

**è§£æï¼š**

**6. br10x ç¡¬ä»¶ä¸­æœ‰å‡ ç»„å¯ç”¨äºè®¿å­˜å…³ç³»æ§åˆ¶çš„ sync channelï¼šï¼ˆBï¼‰**

A. 1

B. 2

C. 3

D. 4

**è§£æï¼šè¯¥é¢˜æœ¬æ„ä¸ºç›®å‰ pipeline ä¸­çš„ç­–ç•¥ä½¿ç”¨äº†å¤šå°‘ sync channel è¿›è¡Œè®¿å­˜ç®¡ç†ï¼Œå®é™…ä¸Š BC å‡ä¸ºåˆç†ç­”æ¡ˆ**

**1ã€****åæ±‡ç¼–æ–‡ä»¶ä¸­çš„æŒ‡ä»¤åœ°å€ï¼Œä¸ trace ä¸­çš„ PC å€¼çš„å¯¹åº”å…³ç³»æ˜¯ï¼šï¼ˆAï¼‰**

A. HEX(PC_value) = HEX(dis_addr) // 8

B. HEX(PC_value) = HEX(dis_addr)

C. HEX(PC_value) = HEX(dis_addr) // 16

D. HEX(PC_value) = HEX(dis_addr) // 32

**è§£æï¼š**

**2ã€inst trace tlr é‡Œé¢çš„æ•°æ®ä¸º 03db5004f3ï¼Œfp32 å¯¹åº”çš„æ•°æ®ä¸ºï¼šï¼ˆBï¼‰**

A. 3db5004f = 0.0883794948459

B. 3db504f3 = 0.0883883461356

C. 04f33db5 = 5.71856944083e-36

D. b53df304 = -7.07616209183e-07

**è§£æï¼š**

**3ã€simt one or two-source inst / simt three-source instï¼Œä¸” src éƒ½ä¸º tlrï¼Œå…¶ issue cycle æ•°åˆ†åˆ«ä¸ºï¼šï¼ˆBï¼‰**

A. 1/2

B. 2/4

C. 1/3

D. 2/3

**è§£æï¼š**

**4.æŒ‡ä»¤å‘¨æœŸæœ‰å“ªå‡ ä¸ªï¼šï¼ˆACDEFï¼‰**

A. å–å€

B. ç¼–ç 

C. è¯‘ç 

D. æ‰§è¡Œ

E. è®¿å­˜

F. å†™å›

**è§£æï¼š**

**5. æœ‰å¤šå°‘ç§æŒ‡ä»¤å†’é™©å†²çªï¼šï¼ˆABCï¼‰**

A. Structure Hazardâ€“ è®¡ç®—èµ„æºå†²çª

B. Data Hazardâ€“ æ•°æ®ä¾èµ–å†²çª

C. Control Hazardâ€“ åˆ†æ”¯æ§åˆ¶å†²çª

**è§£æï¼š**

**6. br10x ç¡¬ä»¶ä¸­æœ‰å‡ ç»„å¯ç”¨äºè®¿å­˜å…³ç³»æ§åˆ¶çš„ sync channelï¼šï¼ˆBï¼‰**

A. 1

B. 2

C. 3

D. 4

**è§£æï¼šè¯¥é¢˜æœ¬æ„ä¸ºç›®å‰ pipeline ä¸­çš„ç­–ç•¥ä½¿ç”¨äº†å¤šå°‘ sync channel è¿›è¡Œè®¿å­˜ç®¡ç†ï¼Œå®é™…ä¸Š BC å‡ä¸ºåˆç†ç­”æ¡ˆ**

**Performance Programming**

1. GEMM Write, LSC Read çš„å¸¦å®½åˆ†åˆ«æ˜¯ï¼ˆï¼‰ï¼Ÿ[å•é€‰é¢˜] *

| |


|---|

|Aã€4kb;2kb(æ­£ç¡®ç­”æ¡ˆ)|

|Bã€4kb;4kb|

|Cã€2kb;2kb|

|Dã€2kb;4kb|

**ç­”æ¡ˆè§£æï¼š**GEMM write 4kb/cycle; lsc read 2kb/cycle

1. åœ¨ Tmode ä¸‹ï¼Œä¸‹åˆ—è¯´æ³•æ­£ç¡®çš„æ˜¯ï¼ˆï¼‰ï¼Ÿ*

| |


|---|

|Aã€æ¯ä¸ª CWARP éƒ½èƒ½è®¿é—®æ‰€æœ‰çš„ TLR(æ­£ç¡®ç­”æ¡ˆ)|

|Bã€æ¯ä¸ª CWARP éƒ½èƒ½è®¿é—®æ‰€æœ‰çš„ WSR|

|Cã€åœ¨ EU ä¸­ï¼Œæœ€å¤šæœ‰ 8 ä¸ª CWARP å¹¶è¡Œ (æ­£ç¡®ç­”æ¡ˆ)|

|Dã€æ¯ä¸ª CWAP åŒ…å« 32 ä¸ª Thread(æ­£ç¡®ç­”æ¡ˆ)|

**ç­”æ¡ˆè§£æï¼š**æ¯ä¸ª CWARP æœ‰è‡ªå·±çš„ä¸€ç»„ WSR

1. 3ã€L1P5 Buffer çš„å¤§å°æ˜¯ï¼ˆï¼‰ï¼Ÿ[å•é€‰é¢˜] *

| |


|---|

|Aã€3MB|

|Bã€4MB(æ­£ç¡®ç­”æ¡ˆ)|

|Cã€7MB|

|Dã€8MB|

**ç­”æ¡ˆè§£æï¼š**L1P5 buffer çš„å¤§å°æ˜¯ 4MB

1. åœ¨ Gmode ä¸‹ï¼Œä¸‹åˆ—è¯´æ³•é”™è¯¯çš„æ˜¯ï¼ˆï¼‰ï¼Ÿ*

| |


|---|

|Aã€æ¯ä¸ª WARP éƒ½æœ‰è‡ªå·±çš„ä¸€ç»„ TLR|

|Bã€æ¯ä¸ª WARP éƒ½æœ‰è‡ªå·±çš„ä¸€ç»„ WSR|

|Cã€æ¯ä¸ª Thread Group æœ€å¤šæœ‰ 8 ä¸ª WARPS(æ­£ç¡®ç­”æ¡ˆ)|

|Dã€æ¯ä¸ª CU æœ€å¤š 32 ä¸ª Thread Groups(æ­£ç¡®ç­”æ¡ˆ)|

**ç­”æ¡ˆè§£æï¼š**æ¯ä¸ª Thread Group æœ€å¤šæœ‰ 32 ä¸ª WARPS, æ¯ä¸ª CU æœ€å¤š 8 ä¸ª Thread Groups

1. ä»¥ä¸‹ fence æŒ‡ä»¤ä¸­ï¼Œå¯ä»¥ flush l1p75 cache çš„æ˜¯ï¼ˆï¼‰ï¼Ÿ*

| |


|---|

|Aã€fll1(æ­£ç¡®ç­”æ¡ˆ)|

|Bã€ackl1|

|Cã€ackgmb(æ­£ç¡®ç­”æ¡ˆ)|

|Dã€flmask(æ­£ç¡®ç­”æ¡ˆ)|

**ç­”æ¡ˆè§£æï¼š**ackl1 åªèƒ½ flush l1 æ•°æ®

1. å¯¹äº barrier ä»£ä»·æ’åºæ­£ç¡®çš„æ˜¯ï¼ˆï¼‰ï¼Ÿ[å•é€‰é¢˜] *

| |


|---|

|Aã€bar.dtg/bar.ntg>bar.wtg>bar.batch>[[bar.tg](http://bar.tg/)]([http://bar.tg/](http://bar.tg/))|

|Bã€bar.dtg/bar.ntg>bar.batch>bar.wtg>[[bar.tg](http://bar.tg/)]([http://bar.tg/](http://bar.tg/))(æ­£ç¡®ç­”æ¡ˆ)|

|Cã€bar.dtg/bar.wtg>bar.batch>bar.ntg>[[bar.tg](http://bar.tg/)]([http://bar.tg/](http://bar.tg/))|

|Dã€[[bar.tg](http://bar.tg/)]([http://bar.tg/](http://bar.tg/))>bar.wtg>bar.batch>bar.dtg/bar.ntg|

**ç­”æ¡ˆè§£æï¼š**bar.dtg/bar.ntg>bar.batch>bar.wtg>[[bar.tg](http://bar.tg/)]([http://bar.tg/](http://bar.tg/))

1. å¯¹äºä¸åŒ CU ä¸­çš„ä¸¤ä¸ª EU ä¹‹é—´çš„å†™åè¯»æƒ…å†µï¼Œéœ€è¦è¿›è¡Œçš„ fence/bar è¡Œä¸ºæ˜¯ï¼ˆï¼‰ï¼Ÿ[å•é€‰é¢˜] *

| |


|---|

|Aã€PRD->ackl1->[[bar.tg](http://bar.tg/)]([http://bar.tg/](http://bar.tg/))->CSM|

|Bã€PRD->ackgmb(or invl1)->[[bar.tg](http://bar.tg/)]([http://bar.tg/](http://bar.tg/))->CSM|

|Cã€PRD->ackgmb(or invl1)->bar.wtg->CSM(æ­£ç¡®ç­”æ¡ˆ)|

|Dã€PRD->ackgmb->CSM|

**ç­”æ¡ˆè§£æï¼š**PRD->ackgmb(or invl1)->bar.wtg->CSM

1. ä¸‹åˆ—å±äºå¯ä»¥æé«˜ç¡¬ä»¶åˆ©ç”¨ç‡çš„ç¼–ç¨‹æ–¹æ³•æœ‰ï¼ˆï¼‰ï¼Ÿ*

| |


|---|

|Aã€ä¹’ä¹“ buffer pipeline(æ­£ç¡®ç­”æ¡ˆ)|

|Bã€åœ¨ hazard ç›¸å…³çš„æŒ‡ä»¤ä¸­é—´æ’å…¥ä¸ç›¸å…³çš„æŒ‡ä»¤ï¼Œå‡å°‘ NOP/HOLD(æ­£ç¡®ç­”æ¡ˆ)|

|Cã€å¤š CWARP å¹¶è¡Œ (æ­£ç¡®ç­”æ¡ˆ)|

|Dã€ALU æ‰€éœ€æ“ä½œæ•°å°½é‡æå‰ load(æ­£ç¡®ç­”æ¡ˆ)|

**ç­”æ¡ˆè§£æï¼š**å…¨éƒ¨æ­£ç¡®

cuda pro model for hopper

nvcc runtime nvrtc

parallel threa exec isa

cudnn bestpr

get star with dl perf

gpu perf back

optimi conv lay

kernel profiling guide

optimizing para red in
