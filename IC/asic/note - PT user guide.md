[Prime Time User Guide翻译计划（一） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/456261887)
## Prime Time简介

PrimeTime全套工具执行全芯片，门级静态时序分析，这是芯片设计的设计和分析流程中重要的一部分。该工具通过检查所有路径是否存在时序违例来彻底地使设计的时序性能有效。不用使用逻辑仿真和测试向量。要了解更多的PT工具基础，请参阅：

- PT的性能
- PT的附加工具
- 在执行流程中使用PT
- Galaxy执行工具的兼容性
- 静态时序分析回顾

## PT的性能

在PT中你可以执行很多种类的设计检查和分析

- **设计检查：**

1. 建立，保持，恢复，移除约束
2. 用户自定义的数据到数据的时序约束
3. 门控时钟的建立和保持约束
4. 时钟的最小周期和最小脉冲宽度
5. 设计规则（最大和最小过度时间，电容，扇出）

- **分析功能**

1. 多个时钟和时钟频率
2. 伪路径和多时钟路径时序例外
3. 透明锁存分析和时间借用
4. 对建立和保持约束同时进行最小和最大延时分析
5. 芯片上工艺，电压和温度条件变量分析
6. 应用于指定输入的常量或特定转换的案例分析
7. 使用模块特定的操作模式进行模式分析，像RAM模块的读模式或写模式
8. 报告导致最大时序违例的单元的瓶颈分析
9. 物理上相邻线间的串扰分析
10. 使用HyperScale技术进行有效的层次分析
11. 综合约束一致性行检查
12. ECO分析，通过插入buffers调整cell大小和更换cell来纠正违例并优化功耗。

## PT的附加工具

PT全套工具包含下面的附加特性，其需要相应的licenses

**Prime Time-SI，支持以下PT SI信号完整功能：**

1. 信号完整性分析

2. 静态噪声分析

3. 约束的一致性

4. 读写二进制文件

5. IR drop分析

6. 用write_spice_deck命令产生一个SPICE Deck

**PrimeTime ADV，支持以下PTADV先进的功能**

1. 参数化片上的变量
2. 多输入切换分析
3. 物理感知ＥＣＯ
4. 基于内核的许可
5. 在ＰＴ中运行ＥＣＯ更改列表

**Prime Time-ADV PLUS，支持以下PT ADVP先进的功能**

1. 使用机器学习加速功耗恢复

2. 使用基于矩的建模进行分析

3. GPD寄生探测器

4. GUI 中的布局视图和 ECO

5. ECO 和 M1 PG straps

6. 编写 Ansys RedHawk RH-SC STA 文件

**PrimePower，支持PrimePower 先进的功耗分析**

PrimePower附加工具分析基于单元的设计的全芯片功耗。 它支持无矢量和基于矢量的峰值功率和平均功率分析。更多的信息，请参阅PrimePower用户指导。

## 在执行流程中使用PrimeTime

作为新思Galaxy设计平台的一部分，PT工具能够很好的配合其他Galaxy工具，像Design Compiler, IC Compiler II, 和StarRC。这些工具共享许多相同的工艺库，数据库和命令。如下图所示。

![](https://pic1.zhimg.com/80/v2-bde6f627c2cc14ccc4b72b8f59515c90_720w.webp)

  

从RTL设计开始，Design Compiler工具产生门级网表。从门级网表和物理库信息中，物理实现工具IC Compiler 执行布局布线，StarRC寄生提取工具从芯片版图数据库中提取寄生的RC参数。

PT工具读取门级网表和寄生参数，并使用逻辑库中提供的信息来验证设计的时序。如果工具发现任何的违例，PT就能产生ECO并指导物理实现工具去修复违例并优化功耗。

PT也能作为独立的静态时序分析工具在其他的设计流程中执行。

## Glaxy 执行工具的兼容性

静态时序分析工具PT和综合工具DC，布局布线工具ICC能够很好的一起工作，这些工具在下面这些地方是兼容的：

1. 使用相同的逻辑库，读入同样的设计文件

2. 都支持新思的设计约束文件，即用.SDC格式的进行时序和面积约束

3. 共享很多命令，例如：create_clock, set_input_delay, report_timing等，

4. 有相同的延时计算算法，并且计算结果也近似

5. 产生同样格式的时序报告

PT能够生成更改列表给icc提供ECO指导，这些列表能够修复时序违例和优化功耗。

尽管DC，和ICC Ⅱ也有静态时序分析功能，但是PT能够更快，更精确，更灵活的分析时序信息，同时PT也提供许多其他工具不支持的特性。

### **STA回顾**

静态时序分析是一个验证设计时序性能的方法，通过检查所有可能的时序违例路径。PT将一个设计分解成时序路径，沿着每条路径计算信号的传播延时，并检查时序约束在设计内部和输入/输出接口的违例。

另一种执行时序分析的方法是使用动态仿真，其决定了电路对于一组给定的输入激励向量的完整行为。和动态仿真相比，STA是更快的。因其不需要仿真电路的逻辑运算。STA也是更全面的，因为它检查了所有的时序路径，而不只是由特殊一组测试向量引起的逻辑条件活动。但是，STA仅仅检查电路的时序，而不检查其功能的正确与否。

**时序路径：**

当执行时序分析时，PT首先将设计分解成时序路径，每一个时序路径由下面的元素组成：

起始点：时序路径的起点，数据在时钟边缘launch或者数据必须在特定的时间有效，每一个发起点必须是输入端口或者是寄存器的时钟引脚。

组合逻辑网络：没有内存或者内部状态的元素。组和逻辑包括与，或，非门和反相器，但是不包括触发器，锁存器，寄存器和RAM。

终点：时序路径的终点。那里，数据由时钟沿capture或者是在特定的时间有效，每一个终点必须是寄存器数据的输入引脚或者输出端口。下图展示了一个简单设计中的时序路径：

![](https://pic4.zhimg.com/80/v2-fa61272cd67fed4aae9c0b8665248c07_720w.webp)

上图中每一个logic代表一个组和逻辑网络，每一个路径起始点在数据的发起点，通过一些组和逻辑，在数据被捕获那一点结束。

![](https://pic1.zhimg.com/80/v2-2bbf4fe7bd51cf4f86aa14e625c9c89c_720w.webp)

一个组和逻辑可能包含多个路径，如下图所示，PT使用最长的路径去计算最大的延时，使用最短的路径计算最小的延时。

![](https://pic1.zhimg.com/80/v2-1317b208e3ecbcd5c7ee3138b4aef83c_720w.webp)

  

PT也为下面这些类型的路径做时序分析：

- 时钟路径：从时钟输入端口或单元引脚，通过一个或多个buffers或反相器，到时序单元的时钟引脚。进行数据的建立时间和保持时间的检查。
- 门控时钟路径：从一个输入端口到门控时钟单元；对门控时钟进行建立时间和保持时间的检查。
- 异步路径：从一个输入端口到一个时序器件的异步置位或清除引脚；进行恢复时间和移除时间的检查。

![](https://pic3.zhimg.com/80/v2-ee046dece0953530edbbfd6ed2ee8aca_720w.webp)

  

**延时计算**

将一个设计划分成一些时序路径之后，PT工具沿着每条路径计算延迟。路径的总延时是路径中所有的cell和线延时的总和。

**cell延时**

cell延时是路径中逻辑门从输入到输出的延时。在缺少sdf文件的反标延时信息的情况下，工具从逻辑库中提供的延时表计算cell延时。

通常，一个延时表将所有的延时列成一个或者多个变量相关的函数，像输入过度时间和输出负载电容。从这些延时表中，工具计算每一个cell的延时。必要时，PT使用插值或外推表值去获得一个设计在当前的条件下的延时值。

**线延时**

线延时是时序路径上从cell的输出到下一个cell的输入的延时量。这个延时是由于两个cell之间互连线的寄生电容，净电阻和驱动单元的有限的驱动强度造成的。

**PT工具用下面的方法计算线延时：**

1. 估计来自线负载模型的延时；这个方法使用在layout之前，这时芯片的布局还是未知的。

2. 从标准延时格式（SDF）文件中使用具体的时间值反标。

3. 从galaxy寄生数据库（GPD），标准寄生交换格式（SPEF），详细的标准寄生格式（DSPF），减少标准寄生格式（RSPF）文件中，使用详细的寄生电阻和电容数据反标。

  

**约束检查**

在PT确定时序路径并计算路径延时之后，它将检查时序约束的违例，例如建立和保持的约束：

一个建立（set up）约束明确了，在时钟沿于该器件捕获数据之前，时序器件的输入端的数据要有多少必要的时间保持有效。这个约束在数据路径上，强制加入一个相对时钟沿的最大的延时。

一个保持（hold）约束明确了，在时钟沿于该器件捕获数据后，时序器件的输入端的数据要有多少必要的时间保持稳定。这个约束在数据路径上，强制加入一个相对于时钟沿的最小的延时。

除了建立和保持约束之外，PT也能检查恢复和移除约束，数据到数据的约束，门控时钟的建立和保持约束，以及时钟信号的最小脉冲宽度。

避免违规的时间量称为松弛（slack），例如，对于一个建立约束，如果一个信号在8ns内必须到达cell的输入，假如是经过5ns到达，那么slack就是3ns。Slack为0意味着约束是勉强被满足。一个负的slack意味着时序的违例。

**例：触发器的建立和保持检查**

下面的例子展示了对于一个触发器PT如何检查建立和保持约束。

![](https://pic3.zhimg.com/80/v2-2a2e45df0b86d337091473e5c3dc1aa6_720w.webp)

  

对于这个例子，假定触发器是定义在一个逻辑库中，有最小建立时间为一个时间单元，最小的保持时间为0个时间单元。时钟周期被定义为10个时间单元。逻辑库中指定的时间单位是ns或ps。

默认情况下，工具假定传播信号在一个周期内通过所有的数据路径。因此，当工具执行建立检查时，它验证一个周期内从FF1发起到达FF2的数据，是否在数据被FF2下一个时钟沿捕获的前一个时间单元到达。如果数据路径延迟太长，PT就会报告一个时序违例。对于建立检查，PT考虑数据路径最长可能的延时，考虑FF1和FF2之间的时钟路径最短可能的延时。

当工具执行一个保持检查时，它验证从FF1发起到达FF2的数据，不能比前一个时钟周期的捕获沿更快。这个检查确保在前一个周期时钟沿捕获数据之后，数据在FF2的输入端已经稳定足够长的时间。对于保持检查，PT考虑数据路径的最短延时，以及FF1到FF2之间的时钟路径的最长的延时。如果时钟路径有很长的延时，那么就可能出现一个保持违例。

## 建立保持的检查，以锁存器为例

基于锁存器的设计通常使用两个相位不同的非重叠时钟去控制连续寄存器中的数据路径 ，在这些情况下，PT使用时间借用（time borrowing）去减少后续路径的约束。

例如，考虑两个不同相位的锁存器路径如下图所示。下面的三个锁存器是电平敏感的，当输入G是高电平时门是导通的。锁存器L1和L3由PH1控制的。锁存器输出端从上升沿发起数据，锁存器的输入端在下降沿捕获数据。在这个例子中，假定锁存器的建立时间和延迟是0。

![](https://pic3.zhimg.com/80/v2-5fe89b993fe120567f5d1ba3488d402e_720w.webp)

对于从L1到L2的路径，PH1的上升沿发起数据。数据必须在PH2的下降沿之前（即time = 20）到达L2。这个时序要求标记为setup1。根据L1到L2之间的延迟值，数据可能在PH2的上升沿（time = 10）之前或者之后到达，即由上图中虚线箭头暗示的标签“Arrival a” and “Arrival b”。在time = 20之后到达是一个时序违例。

如果数据在PH2的上升沿之前（time = 10）到达L2，那么从L2到L3路径的数据开始由PH2的上升沿（time = 10）发起。就像一个同步触发器的操作。在这个例子中，第二个路径没有借用时间。从L2到L3的时序要求标记为setup 2a。

如果数据在PH2的上升沿之后到达（Arrival b），那么第一条路径（从L1到L2）从第二条（L2 到L3）路径借用了时间。在这个例子中，第二条路径发起的数据不是出现在上升沿，而是数据在L2的到达时间，在PH2的上升和下降沿之间的某个时间。这个时序要求是标记为setup 2b。当借用时间发生时，路径起源于D端的引脚而不是L2的G端的引脚。

对于第一条路径（L1到L2），如果借用时间发生，PT报告建立的松弛量是0。如果数据在上升沿之前到达（time = 10）松弛量是正的，如果数据在下降沿之后到达（time = 20）松弛量是负的，此时有个时序违例。

执行保持检查，PT会考虑到和建立检查相关的发起和捕获沿，如下图所示，它验证在起始点发起的数据不会很快的到达终点，由此确保在先前的周期发起的数据是锁存的，而不是被新的数据覆盖了。

![](https://pic4.zhimg.com/80/v2-7eda0ee1af6a9faf0da5f75b88edc72b_720w.webp)

## 时序例外

如果某些路径不想根据PT默认的建立和保持行为进行操作，，则需要指定这些路径为时序例外。否则，工具可能错误的报告这些路径存在时序违例。

PT工具允许你指定下面例外的种类：

- 错误路径：由于逻辑配置、预期数据序列或操作模式而从不敏感的路径。
- 多周期路径：从发起到捕获需要一个以上的时钟周期路径。
- 最小或最大延时路径：必须满足你明确指定时间值的延时约束路径。