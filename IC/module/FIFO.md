---
dateCreated: 2025-04-09
dateModified: 2025-04-09
---

# 资料

[异步FIFO设计原理与设计方法以及重要问题汇总（包含verilog代码|Testbench|仿真结果）-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2294314)

异步FIFO深度计算异步FIFO面试题

[Clifford E. Cummings的异步FIFO设计论文1](./src/docs/Simulation%20and%20Synthesis%20Techniques%20for%20Asynchronous%20FIFO%20Design.pdf)

[Clifford E. Cummings的异步FIFO设计论文2](./src/docs/Simulation%20and%20Synthesis%20Techniques%20for%20Asynchronous%20FIFO%20Design%20with%20Asynchronous%20Pointer%20Comparisons.pdf)

跨时钟域文献:跨越鸿沟_同步世界中的异步信号(中文版


# 定义

FIFO 即 First In First Out，是一种先进先出数据存储、缓冲器，没有外部读写地址，而是通过计数器实现地址自动的加一操作来控制读写，这也就决定了 FIFO 只能顺序的读写数据，而不能随机读写。

分为同步和异步 FIFO：同步内核为读写双口 RAM；异步需要真双口 RAM，专门的握手信号进行跨时钟域。FIFO 是异步数据传输时常用的存储器，多 bit 数据异步传输时，无论是从快时钟域到慢时钟域，还是从慢时钟域到快时钟域，都可以使用 FIFO 处理。

主要用途有：

1. 异步 FIFO**跨时钟域**交互数据。
2. **不同数据位宽**读写匹配。
3. 高速突发数据平均处理，降低瞬时处理速率，起到数据暂存的功能。

FIFO 参数包括：数据宽度、深度、空、满、读写时钟、接近空、接近满。

- 空/满标志

读指针：总是指向下一个将写入的单元，复位值 0；写指针：总是指向下一个将读出的单元，复位值 0。

读写相等，FIFO 空：复位时；读指针追赶上写指针时

读写再次相同，FIFO 满：写指针转一圈，折返追上读指针。

FIFO 容量认定为 $2^{AW}-1$，使用 $wr_cnt-rd_cnt$ 可以避免写入 $2^{AW}$ 造成混淆。

为了区分满和空，可以采用两种方法：

1. 指针额外添加一位，当写指针增加并越过最后一个 FIFO 地址时写指针这个未用的 MSB 加 1，其余归零。读指针同样。若两个指针 MSB 相同，折回次数相等，FIFO 空。
2. 使用格雷码判断。方法 1 在异步 FIFO 中容易出现问题，计数值需要长时间转换，读写时钟不同步容易出现错误判断，因此即使在中间状态采样也能正确判断 FIFO 空满，要求每次只能有 1 bit 变化（即使中间状态采样，也只有递增前和递增后的值，只会造成读写的延时）。

   格雷码属于可靠编码，错误最小，相邻位转换时只有一位变化，大大减少了状态转换造成逻辑混乱的可能性。格雷码非权重码，每一码没有确定大小。格雷与二进制转换：gray->bin- 最左不变，每位与左边 XOR；bin->gray- 最左不变，最右开始每一位与左边 XOR

# 同步 FIFO

FIFO 全称 `First In First Out`，即先进先出先入先出存储器，功能与软件数据结构中队列相似。FIFO 常用于突发数据的缓冲、流式数据和块式数据的转换, 比如有时数据源端和受端并不能以一致的步调发收数据, 但在较大时间尺度上平均吞吐率一致, 比如音频数据流传递到 MPU 处理时一般先缓存为数据块。FIFO 也是很多算法依赖的重要数据结构。

## IO

![[assests/FIFO.png]]

数据端口：除时钟外, 它还包含数据输入 (din)、写入使能 (write)、数据输出 (doubt) 和读出使能 (read) 等信号。每次写入使能有效，将当时数据输入端的数据写入，同时 FIFO 中有效数据的数量增 1；每次读出使能有效，最先写入的、还未读出的数据将读出到数据输出口，同时 FIFO 中有效数据的数量减 1。

为了便于使用它的逻辑判断 FIFO 中有效数据的个数，还需要有写入计数和读出计数，以及由这两个计数衍生的数据个数、空、满等信号。

<table>
<tbody>
<tr>
<td> DW</td>
<td> 数据宽度</td>
</tr>
<tr>
<td> AW</td>
<td> 地址宽度</td>
</tr>
</tbody>
</table>

| 信号                 | 方向  | 意义                           |
| ------------------ | --- | ---------------------------- |
| clk                | I   | 时钟                           |
| din[DW-1: 0]       | I   | 数据输入                         |
| write              | I   | 写入使能                         |
| doubt[DW-1 : 0]     | O   | 数据输出                         |
| read               | I   | 读出使能                         |
| wr_cnt[AW-1 : 0]   | O   | 写入计数                         |
| rd_cnt[AW-1 : 0]   | O   | 读出计数                         |
| data_cnt[AW-1 : 0] | O   | 有效数据数，由 $wr\_cnt-rd\_cnt$ 获得   |
| full               | O   | 满标志，由 $data\_cnt==CAPACITY$ 获得 |
| empty              | O   | 空标志                          |

## 实现

![[assests/scFIFO.png]]

同步 FIFO 可以用简双口 RAM 实现，写入读出地址各一个计数器，计数器由读写信号驱动增一。虽然计数在计满时会溢出回 0，但只要计数模为 $2^{AW}$，不发生过写过读，就能保证数据计数不出错。

> 注意：这种实现，实际存储的数据容量为 $2^{AW}-1$

- 为匹配计数模 $2^{AW}$，简单双口 RAM 数据字深也为 $2^{AW}$。
- 为避免写入数据量为 $2^{AW}$ 时，$wr\_cnt-rd\_cnt=0$ 与数据量为 0 混淆，FIFO 容量即 CAPACITY 认定为 $2^{AW}-1$。
- 为了避免过写过读，FIFO 逻辑保证 full 不写入，empty 不读出。

# 异步 FIFO

双时钟 FIFO (DCFIFO) 除能完成单时钟 FIFO 的常用功能外，还有一个最重要的作用是实现跨时钟域数据传递。一般写入端由一个时钟驱动，而读取端由另一个时钟驱动，读和写计数也应相互传递到另一端, 以便每一端都可以有数据计数和空/满标志。

通过格雷码将写/读计数传递到另一侧 (另一时钟域)，每侧都有读写计数，写入侧的读计数是跨域传递而来，是有两个周期延迟的，同样读出侧的写计数也是跨域传递而来，也有两个周期延迟。

![[assests/async_FIFO.png]]

[【原创】异步FIFO设计原理详解 (含RTL代码和Testbench代码)_异步fifo testbench-CSDN博客](https://blog.csdn.net/qq_40807206/article/details/109555162)

FIFO 在硬件上是一种地址依次自增的 Simple Dual Port RAM，按读数据和写数据工作的时钟域是否相同分为同步 FIFO 和异步 FIFO，其中同步 FIFO 是指读时钟和写时钟为同步时钟，常用于数据缓存和数据位宽转换；异步 FIFO 通常情况下是指读时钟和写时钟频率有差异，即由两个异步时钟驱动的 FIFO，由于读写操作是独立的，故常用于多比特数据跨时钟域处理。

## 二进制转格雷码

异步 FIFO 是通过比较读指针和写指针的位置来判断 FIFO 是否写满或读空，但是不可以直接比较两个指针，因为他们属于不同时钟域，直接相比可能会产生亚稳态从而引起误判，这就需要将两个指针分别进行跨时钟域处理，然后再判断。但是存在一个问题，自然二进制编码的地址在状态翻转的时候是多位变化，这就可能会产生竞争现象并有可能被另一个时钟域的触发器采样到，从而引发误判。最容易的解决方法就是将自然二进制编码的地址转为格雷码编码的地址。


## 空满产生

对于 4 位地址，实际用 5 位来计数，最高位用来判断计数标志。所以判断 “写满” 标志的方法就是：写指针和读指针最高位的数据不同，而其他位都相同。
通过总结规律可以总结得到：最高位和次高位不同，其余位相同时FIFO写满。例如，第一圈和第二圈第3个指针分别是是0-011和1-111；第一圈和第二圈第7个指针分别是是0-101和1-001。所以，判断读写指针是否写满时，先看高两位是否不同和其余位是否相同，若满足则写指针追上读指针（领先一圈），FIFO队列为“满”状态。