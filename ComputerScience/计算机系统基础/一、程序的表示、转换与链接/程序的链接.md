---
dateCreated: 2025-08-02
dateModified: 2025-08-02
tags: pragma
---

一个大的程序往往会分成多个源程序文件来编写, 因而需要对各个不同源程序文件分别进行编译或汇编, 以生成多个不同的目标代码文件, 这些目标代码文件中包含指令、数据和其他说明信息。此外, 在程序中还会调用一些标准库函数。为了生成一个可执行文件, 需要将所有关联到的目标代码文件, 包括用到的标准库函数目标文件, 按照某种形式组合在一起, 形成一个具有统一地址空间的可被加载到存储器直接执行的程序。这种**将一个程序的所有关联模块对应的目标代码文件结合在一起, 以形成一个可执行文件的: 过程称为链接**。现在由专门的链接程序 (linkeer, 也称为链接器) 来实现。

# 4.1 编译、汇编和静态链接

链接概念早在高级编程语言出现之前就已存在。例如，在汇编语言代码中，可以用一个标号表示某个转移**目标指令的地址** (即给定了一个标号的定义), 而在另一条转移指令中引用该标号：也可以用一个标号表示某个**操作数的地址**，而在某条使用该操作数的指令中引用该标号。因而，在对汇编语言源程序进行汇编的过程中，对每个标号的引用，需要找到该标号对应的定义，建立每个标号的引用和其定义之间的关联关系，从而在引用标号的指令中正确地填入对应的地址码字段，以保证能访问到所引用的符号定义处的的信息。

在高级编程语言出现之后，程序功能越来越复杂，规模越来越大，需要多人开发不同的程序模块。在每个程序模块中，包含一些变量和子程序 (函数) 的定义。这些**被定义的变量和子程序的起始地址就是符号定义**，子程序 (函数或过程) 的调用或者在表达中使用变量进行计算就是**符号引用**。某一个模块中定义的符号可以被另一个模块引用，因而最终必须通过链接将程序包含的所有模块合并起来，合并时须在符号引用处处填入定义处的地址。

## 一、编译和汇编

将高级语言源程序文件转换为可执行目标文件通常分为**预处理、编译、汇编和链接**四个步骤。前面三个步骤用来对每个模块 (即源程序文件) 生成**可重定位目标文件 (relocatable object file)**。最后一个步骤为链接,用来将若干可重定位目标文件 (可能包括若干标准库函数目标模块) 组合起来, 生成一个**可执行目标文件 (executable object file)**。有时将可重定位目标文件和可执行目标文件分别简称可重定位文件和可执行文件。

### 以 GCC (GNU Compiler Collection) 处理 C 语言程序为例来说明处理过程

假设我们有一个简单的 C 语言源文件 `hello.c`：

```c
#include <stdio.h>

#define PI 3.14159

int main() {
    printf("Hello, World! PI is %.5f\n", PI);
    return 0;
}
```

`cpp`, `cc1`, `as`, `ld` 是 GCC (GNU Compiler Collection) 在将 C/C++ 源代码转换为可执行程序的过程中，背后调用的**核心工具**。它们分别对应编译流程的四个主要阶段：预处理、编译、汇编和链接。

虽然我们通常直接使用 `gcc` 或 `g++` 命令，但这些命令实际上是**驱动程序 (driver)**，它们会根据需要自动调用这些底层工具来完成具体任务。使用 `gcc` 时可以用 `-v` 查看每一步的处理过程。如果想要得到每一步的结果，也可以分别调用处理。

---

#### 1. 预处理 (Preprocessing)

`cpp` - C/C++ 预处理器 (C/C++ Preprocessor)

**作用**：
预处理阶段主要处理源代码中以 `#` 开头的预处理指令（如 `#include`, `#define`, `#ifdef` 等）。具体任务包括：
* **包含头文件**：将 `#include <stdio.h>` 这样的指令替换为实际的头文件内容。
* **宏展开**：将宏定义（如 `PI`）替换成其定义的值。
* **条件编译**：根据 `#ifdef`, `#ifndef` 等指令决定是否包含某段代码。
* **删除注释**：移除源代码中的注释。
* **处理 #pragma 指令**。

**GCC 命令**：

```bash
gcc -E hello.c -o hello.i

cpp hello.c > hello.i
```

* `-E` 选项告诉 GCC 只进行预处理。
* `-o hello.i` 指定输出文件名为 `hello.i`（通常为 `.i` 后缀）。

**结果**：
生成的 `hello.i` 文件是一个经过预处理的 C 语言源代码文件。它包含了 `stdio.h` 的所有内容，并且 `PI` 已被替换为 `3.14159`，注释也被删除。这个文件仍然是人类可读的 C 代码。

---

#### 2. 编译 (Compilation)

`cc1` - C 编译器 (C Compiler) / `cc1plus` - C++ 编译器

**作用**：
* 将预处理后的 C 语言源代码（`.i` 文件）解析、分析（词法、语法、语义），进行优化，最终翻译成特定目标架构的**汇编语言**代码（`.s` 文件）。
* 编译阶段将预处理后的 C 语言源代码 (`hello.i`) 翻译成特定于目标机器的**汇编语言**代码。这个过程包括：
* 语法分析、语义分析。
* 优化代码（可选，取决于优化选项）。
* 生成与目标处理器架构（如 x86_64）对应的汇编指令。
特点：
* `cc1`/`cc1plus` 通常是**内部工具**，不直接提供给用户在命令行调用。普通用户通过 `gcc`/`g++` 命令并使用 `-S` 选项来触发编译阶段。
* 你可以通过 `gcc -v`（verbose）选项查看 `gcc` 内部是如何调用 `cc1` 的。

**GCC 命令**：

```bash
gcc -S hello.i -o hello.s
```

* `-S` 选项告诉 GCC 只进行到编译阶段，生成汇编代码。
* `-o hello.s` 指定输出文件名为 `hello.s`（通常为 `.s` 后缀）。

> **注意**：你也可以直接从 `.c` 文件开始编译，GCC 会自动先进行预处理再编译：
> ```bash
> gcc -S hello.c -o hello.s
> ```

**结果**：
生成的 `hello.s` 文件是汇编语言源代码文件。它包含的是人类可读的、但与机器指令一一对应的汇编指令（如 `mov`, `call`, `push` 等），针对特定的 CPU 架构。

---

#### 3. 汇编 (Assembly)

`as` - 汇编器 (Assembler)

`as` 是 GNU Binutils (Binary Utilities) 包的一部分，通常称为 **GNU Assembler**。

**作用**：
汇编阶段将汇编语言源代码 (`hello.s`) 翻译成机器可以直接执行的**目标代码**（Object Code）。目标代码是二进制格式的机器指令，但它还不是可以直接运行的完整程序。
* 汇编器 (`as`) 将每条汇编指令转换成对应的机器码（二进制）。
* 生成的目标文件（`.o` 或 `.obj`）包含了机器码、数据、符号表（函数名、变量名等）以及重定位信息。

**GCC 命令**：

```bash
gcc -c hello.s -o hello.o

as hello.s -o hello.o
```

* `-c` 选项告诉 GCC 进行到汇编阶段，生成目标文件，但不进行链接。
* `-o hello.o` 指定输出文件名为 `hello.o`（通常为 `.o` 后缀）。

> **注意**：你也可以直接从 `.c` 或 `.i` 文件开始汇编，GCC 会自动完成前面的步骤：
> ```bash
> gcc -c hello.c -o hello.o
> ```

**结果**：
生成的 `hello.o` 文件是一个**目标文件**（Object File）。它是二进制文件，包含了 `main` 函数的机器码，但其中对 `printf` 函数的调用只是一个**未解析的符号引用**（因为 `printf` 的定义在标准库中，不在这个文件里）。目标文件还包含了重定位信息，告诉链接器将来如何调整地址。

汇编的功能是将编译生成的汇编语言代码转换为机器语言代码。因为通常最终的可执行目标文件由多个不同模块对应的机器语言目标代码组合而形成,所以,在生成单个模块的机器语言目标代码时,不可能确定每条指令或每个数据最终的地址,也即,单个模块的机器语言目标代码需要重新定位, 因此, 通常把汇编生成的机器语言目标代码文件称为可重定位目标文件。

---

#### 4. 链接 (Linking)

`ld` - 链接器 (Linker)

`ld` 也是 GNU Binutils 包的核心组件，称为 **GNU Linker**。

**作用**：
链接阶段将一个或多个目标文件（`.o`）以及所需的库文件（如标准 C 库 `libc.a` 或 `libc.so`）组合起来，形成一个单一的、完整的**可执行文件**。主要任务包括：
* **符号解析**：找到所有未定义符号（如 `printf`）的实际定义。
* **重定位**：将各个目标文件中的代码和数据段合并，并为所有符号（函数、变量）分配最终的内存地址。
* **处理库函数**：将程序中用到的库函数（如 `printf`）的代码链接进来（静态链接）或建立动态链接信息（动态链接）。

`ld` 手动调用非常复杂，需要手动指定启动代码（`crt*.o`）、C 标准库（`-lc`）和动态链接器路径。

**GCC 命令**：

```bash
gcc hello.o -o hello
```

* 这是最常见的链接命令。`gcc` 会自动调用链接器 (`ld`)。
* `hello.o` 是输入的目标文件。
* `-o hello` 指定最终的可执行文件名为 `hello`（在 Windows 上通常是 `hello.exe`）。

> **注意**：GCC 通常允许你一步到位：
> ```bash
> gcc hello.c -o hello
> ```
> 这条命令会依次执行预处理、编译、汇编和链接四个步骤，直接生成可执行文件 `hello`。

**结果**：
生成的 `hello` 文件就是一个**可执行目标文件**。它包含了程序运行所需的所有机器代码（包括 `main` 和 `printf` 等库函数的代码或链接信息），并且已经完成了地址分配，操作系统可以直接加载并运行它。

---

#### 总结

|工具|阶段|主要功能|输入文件|输出文件|所属包/说明|
|---|---|---|---|---|---|
|**`cpp`**|预处理|处理 `#include`, `#define`, 宏展开等|`.c`, `.cpp`|`.i`, `.ii`|GCC (预处理器)|
|**`cc1`**|编译 (C)|C 源码 -> 汇编代码|`.i`|`.s`|GCC (内部编译器, C 专用)|
|**`cc1plus`**|编译 (C++)|C++ 源码 -> 汇编代码|`.ii`|`.s`|GCC (内部编译器, C++ 专用)|
|**`as`**|汇编|汇编代码 -> 目标代码 (机器码)|`.s`|`.o`|GNU Binutils (汇编器)|
|**`ld`**|链接|目标文件 + 库 -> 可执行文件|`.o`, `.a`, `.so`|可执行文件, `.so`, `.a`|GNU Binutils (链接器)|

**总结流程图**：

```
hello.c (源代码)
     |
     |  预处理 (gcc -E)
     V
hello.i (预处理后的C代码)
     |
     |  编译 (gcc -S)
     V
hello.s (汇编代码)
     |
     |  汇编 (gcc -c)
     V
hello.o (目标文件/二进制代码)
     |
     |  链接 (gcc)
     V
hello (可执行文件)
```

当你运行 `gcc hello.c -o hello` 时，GCC 驱动程序会按顺序调用这些工具（`cpp` -> `cc1` -> `as` -> `ld`），最终生成可执行文件 `hello`。通过这四个步骤，GCC 成功地将人类可读的高级 C 语言源代码转换成了计算机可以执行的二进制程序。

### 可执行目标文件的生成

## 目标文件格式

## 符号表与符号解析

### ELF 目标文件格式
### 可重定位目标文件格式
### 可执行目标文件格式
### 4.2.4 可执行文件的存储器映像

计算机内存的存储区域划分是程序运行时的基础，其布局由编译器、链接器和操作系统共同决定。通常，一个运行中的程序（进程）的内存空间会被划分为多个功能不同的区域，**堆（Heap）** 和**栈（Stack）** 是其中最核心的动态区域，其他还包括代码区、数据区等。

### 典型的内存区域划分（从低地址到高地址）

以下是内存布局的经典划分（不同系统可能略有差异，但核心逻辑一致）：

#### 1. 代码区（Text Segment）存放 “执行指令”

- **位置**：通常在内存低地址区域。
- **核心作用**：存储程序编译后的二进制机器指令（CPU 可直接执行的操作码），是程序的 “执行逻辑” 所在。例如，函数中的 “赋值”“循环”“判断” 等操作，最终都会转化为代码区的指令。
- **为什么需要**：
    - 指令需要被 CPU 反复读取执行，因此代码区需保证 “只读性”（防止程序意外修改指令导致逻辑混乱）；
    - 多个进程运行同一程序时（如同时打开两个浏览器窗口），可共享同一份代码区（节省内存，避免重复存储）。
- **特性**：
    - 只读（防止程序意外修改指令）；
    - 可共享（多个进程运行同一程序时，可共享同一份代码区，节省内存）；
    - 大小在编译时就已确定（指令数量固定）。


#### 2. 数据区（Data Segment）存放 “长期存在的变量”

数据区用于存储**全局变量**和**静态变量**（生命周期与程序一致，随程序启动而分配，随程序退出而释放），又细分为：

  
- **初始化数据区（Initialized Data）**：
    
    - 存放 “已显式赋值” 的全局变量和静态变量（如 `int global = 10;` 或 `static int s = 20;`）。
    - 作用：程序启动时直接加载这些变量的初始值，无需运行时再初始化，提高效率。
- **未初始化数据区（BSS Segment）**：
    
    - 存放 “未显式赋值” 的全局变量和静态变量（如 `int global;` 或 `static int s;`）。
    - 作用：操作系统会在程序启动时自动将该区域的变量初始化为 0（或 NULL），避免 “垃圾值” 导致程序异常，同时节省编译后的文件大小（无需存储初始值）。


#### 3. 堆（Heap）存放 “动态创建的数据”

- **位置**：位于数据区上方，从低地址向高地址**动态增长**。
- **核心作用**：用于存储程序运行时 “动态分配” 的内存（大小不确定或需要长期存在的数据）。例如：
    - 程序运行中根据用户输入创建的数组（如 `int[] arr = new int[n];`，`n` 由用户输入决定）；
    - 生命周期超过函数调用的对象（如 C++ 中 `new` 创建的对象，需要手动 `delete` 才释放）。
- **特性**：
    - 大小不固定，可随动态分配扩展（受限于系统总内存）；
    - 由程序员手动管理（C/C++）或垃圾回收机制（Java/Python）自动管理；
    - 内存空间不连续，分配时需要查找空闲块，效率低于栈。
- **为什么需要**：
    - 栈的大小固定且较小，无法满足 “动态大小”“长期存在” 的数据需求；
    - 堆的大小灵活（受限于系统总内存），支持按需分配，适配复杂场景（如动态数据结构、大型对象）。
#### 4. 栈（Stack）### 存放 “临时数据”

- **位置**：位于内存高地址区域，从高地址向低地址**动态增长**（与堆的增长方向相反）。
- **核心作用**：为函数调用提供 “临时存储空间”，主要存储：
    - 函数的局部变量（如 `int a = 5;`，仅在函数执行时存在）；
    - 函数参数（传给函数的输入值，如 `func(10, 20)` 中的 `10` 和 `20`）；
    - 返回地址（函数执行完后，CPU 需回到的原代码位置，确保程序流程连续）。
    - 栈帧信息（维护函数调用的上下文）。
- **特性**：
    - 由编译器自动分配和释放（函数进入时压栈，退出时弹栈）；
    - 内存连续，分配效率极高（仅需移动栈指针）；
    - 大小固定（通常几 MB，超出会导致栈溢出）。
- **为什么需要**：
    - 函数调用是程序执行的基本单元，临时数据需快速创建和销毁，栈的 “自动管理”（编译器控制压栈 / 弹栈）和 “连续内存” 特性可实现极高效率（纳秒级操作）；
    - 避免临时数据占用堆的资源（堆分配效率低）。
#### 5. 命令行参数与环境变量区

- **位置**：通常在栈的顶部（更高地址处）。
- **核心作用**：存储程序启动时的外部输入，包括：
    - 命令行参数（如 `python script.py arg1 arg2` 中的 `arg1` `arg2`，供程序根据参数调整行为）；
    - 环境变量（如系统路径 `PATH`、用户目录 `HOME` 等，让程序能获取系统配置）。
- **为什么需要**：程序并非孤立运行，需与用户、系统交互，该区域是 “外部信息传入程序” 的通道。


### 核心区域的关系与特点

- **地址增长方向**：堆从低地址向高地址 “向上长”，栈从高地址向低地址 “向下长”，两者之间有大量空闲内存，避免冲突。
- **生命周期**：
    - 代码区、数据区：随程序启动存在，直到程序退出。
    - 堆：手动分配后存在，直到手动释放（或 GC 回收）。
    - 栈：仅在函数调用期间存在，函数退出后自动释放。
- **管理方式**：栈由编译器自动管理，堆由程序员（或 GC）手动管理，数据区和代码区由操作系统在程序加载时初始化。

### 举例说明

```c
int global_var; // 未初始化全局变量 → BSS区
int init_global = 100; // 初始化全局变量 → 初始化数据区

int main() {
    int local_var = 20; // 局部变量 → 栈
    static int static_var = 30; // 静态变量 → 初始化数据区
    int* heap_ptr = malloc(100); // 动态分配内存 → 堆
    free(heap_ptr); // 释放堆内存
    return 0;
}
```

总结：内存区域的划分是为了高效管理不同类型的数据（指令、全局变量、临时变量、动态数据等），堆和栈作为动态区域，分别承担 “长期灵活存储” 和 “临时快速存储” 的角色，与其他区域共同支撑程序的运行。
## 符号表和符号解析
### 符号和符号表
### 符号解析
### 与静态库的链接
## 4. 重定位

### 重定位信息
### 重定位过程
## 4.5 动态链接
