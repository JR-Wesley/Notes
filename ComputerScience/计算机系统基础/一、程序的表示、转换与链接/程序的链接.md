---
dateCreated: 2025-08-02
dateModified: 2025-08-02
tags: pragma
---

一个大的程序往往会分成多个源程序文件来编写, 因而需要对各个不同源程序文件分别进行编译或汇编, 以生成多个不同的目标代码文件, 这些目标代码文件中包含指令、数据和其他说明信息。此外, 在程序中还会调用一些标准库函数。为了生成一个可执行文件, 需要将所有关联到的目标代码文件, 包括用到的标准库函数目标文件, 按照某种形式组合在一起, 形成一个具有统一地址空间的可被加载到存储器直接执行的程序。这种**将一个程序的所有关联模块对应的目标代码文件结合在一起, 以形成一个可执行文件的: 过程称为链接**。现在由专门的链接程序 (linkeer, 也称为链接器) 来实现。

# 编译、汇编和静态链接

链接概念早在高级编程语言出现之前就已存在。例如，在汇编语言代码中，可以用一个标号表示某个转移**目标指令的地址** (即给定了一个标号的定义), 而在另一条转移指令中引用该标号：也可以用一个标号表示某个**操作数的地址**，而在某条使用该操作数的指令中引用该标号。因而，在对汇编语言源程序进行汇编的过程中，对每个标号的引用，需要找到该标号对应的定义，建立每个标号的引用和其定义之间的关联关系，从而在引用标号的指令中正确地填入对应的地址码字段，以保证能访问到所引用的符号定义处的的信息。

在高级编程语言出现之后，程序功能越来越复杂，规模越来越大，需要多人开发不同的程序模块。在每个程序模块中，包含一些变量和子程序 (函数) 的定义。这些**被定义的变量和子程序的起始地址就是符号定义**，子程序 (函数或过程) 的调用或者在表达中使用变量进行计算就是**符号引用**。某一个模块中定义的符号可以被另一个模块引用，因而最终必须通过链接将程序包含的所有模块合并起来，合并时须在符号引用处处填入定义处的地址。

## 一、编译和汇编

将高级语言源程序文件转换为可执行目标文件通常分为**预处理、编译、汇编和链接**四个步骤。前面三个步骤用来对每个模块 (即源程序文件) 生成**可重定位目标文件 (relocatable object file)**。最后一个步骤为链接,用来将若干可重定位目标文件 (可能包括若干标准库函数目标模块) 组合起来, 生成一个**可执行目标文件 (executable object file)**。有时将可重定位目标文件和可执行目标文件分别简称可重定位文件和可执行文件。

### 以 GCC (GNU Compiler Collection) 处理 C 语言程序为例来说明处理过程

假设我们有一个简单的 C 语言源文件 `hello.c`：

```c
#include <stdio.h>

#define PI 3.14159

int main() {
    printf("Hello, World! PI is %.5f\n", PI);
    return 0;
}
```

`cpp`, `cc1`, `as`, `ld` 是 GCC (GNU Compiler Collection) 在将 C/C++ 源代码转换为可执行程序的过程中，背后调用的**核心工具**。它们分别对应编译流程的四个主要阶段：预处理、编译、汇编和链接。

虽然我们通常直接使用 `gcc` 或 `g++` 命令，但这些命令实际上是**驱动程序 (driver)**，它们会根据需要自动调用这些底层工具来完成具体任务。使用 `gcc` 时可以用 `-v` 查看每一步的处理过程。如果想要得到每一步的结果，也可以分别调用处理。

---

#### 1. 预处理 (Preprocessing)

`cpp` - C/C++ 预处理器 (C/C++ Preprocessor)

**作用**：
预处理阶段主要处理源代码中以 `#` 开头的预处理指令（如 `#include`, `#define`, `#ifdef` 等）。具体任务包括：
* **包含头文件**：将 `#include <stdio.h>` 这样的指令替换为实际的头文件内容。
* **宏展开**：将宏定义（如 `PI`）替换成其定义的值。
* **条件编译**：根据 `#ifdef`, `#ifndef` 等指令决定是否包含某段代码。
* **删除注释**：移除源代码中的注释。
* **处理 #pragma 指令**。

**GCC 命令**：

```bash
gcc -E hello.c -o hello.i

cpp hello.c > hello.i
```

* `-E` 选项告诉 GCC 只进行预处理。
* `-o hello.i` 指定输出文件名为 `hello.i`（通常为 `.i` 后缀）。

**结果**：
生成的 `hello.i` 文件是一个经过预处理的 C 语言源代码文件。它包含了 `stdio.h` 的所有内容，并且 `PI` 已被替换为 `3.14159`，注释也被删除。这个文件仍然是人类可读的 C 代码。

---

#### 2. 编译 (Compilation)

`cc1` - C 编译器 (C Compiler) / `cc1plus` - C++ 编译器

**作用**：
* 将预处理后的 C 语言源代码（`.i` 文件）解析、分析（词法、语法、语义），进行优化，最终翻译成特定目标架构的**汇编语言**代码（`.s` 文件）。
* 编译阶段将预处理后的 C 语言源代码 (`hello.i`) 翻译成特定于目标机器的**汇编语言**代码。这个过程包括：
* 语法分析、语义分析。
* 优化代码（可选，取决于优化选项）。
* 生成与目标处理器架构（如 x86_64）对应的汇编指令。
特点：
* `cc1`/`cc1plus` 通常是**内部工具**，不直接提供给用户在命令行调用。普通用户通过 `gcc`/`g++` 命令并使用 `-S` 选项来触发编译阶段。
* 你可以通过 `gcc -v`（verbose）选项查看 `gcc` 内部是如何调用 `cc1` 的。

**GCC 命令**：

```bash
gcc -S hello.i -o hello.s
```

* `-S` 选项告诉 GCC 只进行到编译阶段，生成汇编代码。
* `-o hello.s` 指定输出文件名为 `hello.s`（通常为 `.s` 后缀）。

> **注意**：你也可以直接从 `.c` 文件开始编译，GCC 会自动先进行预处理再编译：
> ```bash
> gcc -S hello.c -o hello.s
> ```

**结果**：
生成的 `hello.s` 文件是汇编语言源代码文件。它包含的是人类可读的、但与机器指令一一对应的汇编指令（如 `mov`, `call`, `push` 等），针对特定的 CPU 架构。

---

#### 3. 汇编 (Assembly)

`as` - 汇编器 (Assembler)

`as` 是 GNU Binutils (Binary Utilities) 包的一部分，通常称为 **GNU Assembler**。

**作用**：
汇编阶段将汇编语言源代码 (`hello.s`) 翻译成机器可以直接执行的**目标代码**（Object Code）。目标代码是二进制格式的机器指令，但它还不是可以直接运行的完整程序。
* 汇编器 (`as`) 将每条汇编指令转换成对应的机器码（二进制）。
* 生成的目标文件（`.o` 或 `.obj`）包含了机器码、数据、符号表（函数名、变量名等）以及重定位信息。

**GCC 命令**：

```bash
gcc -c hello.s -o hello.o

as hello.s -o hello.o
```

* `-c` 选项告诉 GCC 进行到汇编阶段，生成目标文件，但不进行链接。
* `-o hello.o` 指定输出文件名为 `hello.o`（通常为 `.o` 后缀）。

> **注意**：你也可以直接从 `.c` 或 `.i` 文件开始汇编，GCC 会自动完成前面的步骤：
> ```bash
> gcc -c hello.c -o hello.o
> ```

**结果**：
生成的 `hello.o` 文件是一个**目标文件**（Object File）。它是二进制文件，包含了 `main` 函数的机器码，但其中对 `printf` 函数的调用只是一个**未解析的符号引用**（因为 `printf` 的定义在标准库中，不在这个文件里）。目标文件还包含了重定位信息，告诉链接器将来如何调整地址。

汇编的功能是将编译生成的汇编语言代码转换为机器语言代码。因为通常最终的可执行目标文件由多个不同模块对应的机器语言目标代码组合而形成,所以,在生成单个模块的机器语言目标代码时,不可能确定每条指令或每个数据最终的地址,也即,单个模块的机器语言目标代码需要重新定位, 因此, 通常把汇编生成的机器语言目标代码文件称为可重定位目标文件。

---

#### 4. 链接 (Linking)

`ld` - 链接器 (Linker)

`ld` 也是 GNU Binutils 包的核心组件，称为 **GNU Linker**。

**作用**：
链接阶段将一个或多个目标文件（`.o`）以及所需的库文件（如标准 C 库 `libc.a` 或 `libc.so`）组合起来，形成一个单一的、完整的**可执行文件**。主要任务包括：
* **符号解析**：找到所有未定义符号（如 `printf`）的实际定义。
* **重定位**：将各个目标文件中的代码和数据段合并，并为所有符号（函数、变量）分配最终的内存地址。
* **处理库函数**：将程序中用到的库函数（如 `printf`）的代码链接进来（静态链接）或建立动态链接信息（动态链接）。

`ld` 手动调用非常复杂，需要手动指定启动代码（`crt*.o`）、C 标准库（`-lc`）和动态链接器路径。

**GCC 命令**：

```bash
gcc hello.o -o hello
```

* 这是最常见的链接命令。`gcc` 会自动调用链接器 (`ld`)。
* `hello.o` 是输入的目标文件。
* `-o hello` 指定最终的可执行文件名为 `hello`（在 Windows 上通常是 `hello.exe`）。

> **注意**：GCC 通常允许你一步到位：
> ```bash
> gcc hello.c -o hello
> ```
> 这条命令会依次执行预处理、编译、汇编和链接四个步骤，直接生成可执行文件 `hello`。

**结果**：
生成的 `hello` 文件就是一个**可执行目标文件**。它包含了程序运行所需的所有机器代码（包括 `main` 和 `printf` 等库函数的代码或链接信息），并且已经完成了地址分配，操作系统可以直接加载并运行它。

---

#### 总结

|工具|阶段|主要功能|输入文件|输出文件|所属包/说明|
|---|---|---|---|---|---|
|**`cpp`**|预处理|处理 `#include`, `#define`, 宏展开等|`.c`, `.cpp`|`.i`, `.ii`|GCC (预处理器)|
|**`cc1`**|编译 (C)|C 源码 -> 汇编代码|`.i`|`.s`|GCC (内部编译器, C 专用)|
|**`cc1plus`**|编译 (C++)|C++ 源码 -> 汇编代码|`.ii`|`.s`|GCC (内部编译器, C++ 专用)|
|**`as`**|汇编|汇编代码 -> 目标代码 (机器码)|`.s`|`.o`|GNU Binutils (汇编器)|
|**`ld`**|链接|目标文件 + 库 -> 可执行文件|`.o`, `.a`, `.so`|可执行文件, `.so`, `.a`|GNU Binutils (链接器)|

**总结流程图**：

```
hello.c (源代码)
     |
     |  预处理 (gcc -E)
     V
hello.i (预处理后的C代码)
     |
     |  编译 (gcc -S)
     V
hello.s (汇编代码)
     |
     |  汇编 (gcc -c)
     V
hello.o (目标文件/二进制代码)
     |
     |  链接 (gcc)
     V
hello (可执行文件)
```

当你运行 `gcc hello.c -o hello` 时，GCC 驱动程序会按顺序调用这些工具（`cpp` -> `cc1` -> `as` -> `ld`），最终生成可执行文件 `hello`。通过这四个步骤，GCC 成功地将人类可读的高级 C 语言源代码转换成了计算机可以执行的二进制程序。

### 可执行目标文件的生成

## 目标文件格式

## 符号表与符号解析

### ELF 目标文件格式
### 可重定位目标文件格式
### 可执行目标文件格式
### 可执行文件的存储器
## 符号表和符号解析
### 符号和符号表
### 符号解析
### 与静态库的链接
## 4. 重定位

### 重定位信息
### 重定位过程
## 4.5 动态链接
